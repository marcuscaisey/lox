// Code generated by "typegen"; DO NOT EDIT.
package protocol

import (
	"bytes"
	"encoding/json"
	"fmt"
	"maps"
	"reflect"
	"slices"
)

type Integer int

type String string

// IntegerOrString contains either of the following types:
//   - [Integer]
//   - [String]
type IntegerOrString struct {
	Value IntegerOrStringValue
}

// IntegerOrStringValue is either of the following types:
//   - [Integer]
//   - [String]
//
//gosumtype:decl IntegerOrStringValue
type IntegerOrStringValue interface {
	isIntegerOrStringValue()
}

func (Integer) isIntegerOrStringValue() {}
func (String) isIntegerOrStringValue()  {}

func (i *IntegerOrString) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var integerValue Integer
	if err := json.Unmarshal(data, &integerValue); err == nil {
		i.Value = integerValue
		return nil
	}
	var stringValue String
	if err := json.Unmarshal(data, &stringValue); err == nil {
		i.Value = stringValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*IntegerOrString](),
	}
}

func (i IntegerOrString) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#progressToken
type ProgressToken = *IntegerOrString

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workDoneProgressParams
type WorkDoneProgressParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken ProgressToken `json:"workDoneToken,omitempty"`
}

type XInitializeParamsClientInfo struct {
	// The name of the client as defined by the client.
	Name string `json:"name"`
	// The client's version as defined by the client.
	Version string `json:"version,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#resourceOperationKind
type ResourceOperationKind string

const (
	// Supports creating new files and folders.
	ResourceOperationKindCreate ResourceOperationKind = "create"
	// Supports renaming existing files and folders.
	ResourceOperationKindRename ResourceOperationKind = "rename"
	// Supports deleting existing files and folders.
	ResourceOperationKindDelete ResourceOperationKind = "delete"
)

var validResourceOperationKindValues = map[string]bool{
	"create": true,
	"rename": true,
	"delete": true,
}

func (r *ResourceOperationKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue string
	if err := json.Unmarshal(data, &stringValue); err != nil {
		return err
	}
	if !validResourceOperationKindValues[stringValue] {
		return fmt.Errorf("cannot unmarshal %v into ResourceOperationKind: custom values are not supported", stringValue)
	}
	*r = ResourceOperationKind(stringValue)

	return nil
}

func (r ResourceOperationKind) MarshalJSON() ([]byte, error) {
	var stringValue = string(r)
	if !validResourceOperationKindValues[stringValue] {
		return nil, fmt.Errorf("cannot marshal %v into ResourceOperationKind: custom values are not supported", stringValue)
	}
	return json.Marshal(stringValue)

}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#failureHandlingKind
type FailureHandlingKind string

const (
	// Applying the workspace change is simply aborted if one of the changes provided
	// fails. All operations executed before the failing operation stay executed.
	FailureHandlingKindAbort FailureHandlingKind = "abort"
	// All operations are executed transactional. That means they either all
	// succeed or no changes at all are applied to the workspace.
	FailureHandlingKindTransactional FailureHandlingKind = "transactional"
	// If the workspace edit contains only textual file changes they are executed transactional.
	// If resource changes (create, rename or delete file) are part of the change the failure
	// handling strategy is abort.
	FailureHandlingKindTextOnlyTransactional FailureHandlingKind = "textOnlyTransactional"
	// The client tries to undo the operations already executed. But there is no
	// guarantee that this is succeeding.
	FailureHandlingKindUndo FailureHandlingKind = "undo"
)

var validFailureHandlingKindValues = map[string]bool{
	"abort":                 true,
	"transactional":         true,
	"textOnlyTransactional": true,
	"undo":                  true,
}

func (f *FailureHandlingKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue string
	if err := json.Unmarshal(data, &stringValue); err != nil {
		return err
	}
	if !validFailureHandlingKindValues[stringValue] {
		return fmt.Errorf("cannot unmarshal %v into FailureHandlingKind: custom values are not supported", stringValue)
	}
	*f = FailureHandlingKind(stringValue)

	return nil
}

func (f FailureHandlingKind) MarshalJSON() ([]byte, error) {
	var stringValue = string(f)
	if !validFailureHandlingKindValues[stringValue] {
		return nil, fmt.Errorf("cannot marshal %v into FailureHandlingKind: custom values are not supported", stringValue)
	}
	return json.Marshal(stringValue)

}

type WorkspaceEditClientCapabilitiesChangeAnnotationSupport struct {
	// Whether the client groups edits with equal labels into tree nodes,
	// for instance all edits labelled with "Changes in Strings" would
	// be a tree node.
	GroupsOnLabel bool `json:"groupsOnLabel,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceEditClientCapabilities
type WorkspaceEditClientCapabilities struct {
	// The client supports versioned document changes in `WorkspaceEdit`s
	DocumentChanges bool `json:"documentChanges,omitempty"`
	// The resource operations the client supports. Clients should at least
	// support 'create', 'rename' and 'delete' files and folders.
	//
	// @since 3.13.0
	ResourceOperations []ResourceOperationKind `json:"resourceOperations,omitempty"`
	// The failure handling strategy of a client if applying the workspace edit
	// fails.
	//
	// @since 3.13.0
	FailureHandling FailureHandlingKind `json:"failureHandling,omitempty"`
	// Whether the client normalizes line endings to the client specific
	// setting.
	// If set to `true` the client will normalize line ending characters
	// in a workspace edit to the client-specified new line
	// character.
	//
	// @since 3.16.0
	NormalizesLineEndings bool `json:"normalizesLineEndings,omitempty"`
	// Whether the client in general supports change annotations on text edits,
	// create file, rename file and delete file changes.
	//
	// @since 3.16.0
	ChangeAnnotationSupport *WorkspaceEditClientCapabilitiesChangeAnnotationSupport `json:"changeAnnotationSupport,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#didChangeConfigurationClientCapabilities
type DidChangeConfigurationClientCapabilities struct {
	// Did change configuration notification supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#didChangeWatchedFilesClientCapabilities
type DidChangeWatchedFilesClientCapabilities struct {
	// Did change watched files notification supports dynamic registration. Please note
	// that the current protocol doesn't support static configuration for file changes
	// from the server side.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the client has support for {@link  RelativePattern relative pattern}
	// or not.
	//
	// @since 3.17.0
	RelativePatternSupport bool `json:"relativePatternSupport,omitempty"`
}

// A symbol kind.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#symbolKind
type SymbolKind uint32

const (
	SymbolKindFile          SymbolKind = 1
	SymbolKindModule        SymbolKind = 2
	SymbolKindNamespace     SymbolKind = 3
	SymbolKindPackage       SymbolKind = 4
	SymbolKindClass         SymbolKind = 5
	SymbolKindMethod        SymbolKind = 6
	SymbolKindProperty      SymbolKind = 7
	SymbolKindField         SymbolKind = 8
	SymbolKindConstructor   SymbolKind = 9
	SymbolKindEnum          SymbolKind = 10
	SymbolKindInterface     SymbolKind = 11
	SymbolKindFunction      SymbolKind = 12
	SymbolKindVariable      SymbolKind = 13
	SymbolKindConstant      SymbolKind = 14
	SymbolKindString        SymbolKind = 15
	SymbolKindNumber        SymbolKind = 16
	SymbolKindBoolean       SymbolKind = 17
	SymbolKindArray         SymbolKind = 18
	SymbolKindObject        SymbolKind = 19
	SymbolKindKey           SymbolKind = 20
	SymbolKindNull          SymbolKind = 21
	SymbolKindEnumMember    SymbolKind = 22
	SymbolKindStruct        SymbolKind = 23
	SymbolKindEvent         SymbolKind = 24
	SymbolKindOperator      SymbolKind = 25
	SymbolKindTypeParameter SymbolKind = 26
)

var validSymbolKindValues = map[uint32]bool{
	1:  true,
	2:  true,
	3:  true,
	4:  true,
	5:  true,
	6:  true,
	7:  true,
	8:  true,
	9:  true,
	10: true,
	11: true,
	12: true,
	13: true,
	14: true,
	15: true,
	16: true,
	17: true,
	18: true,
	19: true,
	20: true,
	21: true,
	22: true,
	23: true,
	24: true,
	25: true,
	26: true,
}

func (s *SymbolKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validSymbolKindValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into SymbolKind: custom values are not supported", uint32Value)
	}
	*s = SymbolKind(uint32Value)

	return nil
}

func (s SymbolKind) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(s)
	if !validSymbolKindValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into SymbolKind: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

type WorkspaceSymbolClientCapabilitiesSymbolKind struct {
	// The symbol kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the symbol kinds from `File` to `Array` as defined in
	// the initial version of the protocol.
	ValueSet []SymbolKind `json:"valueSet,omitempty"`
}

// Symbol tags are extra annotations that tweak the rendering of a symbol.
//
// @since 3.16
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#symbolTag
type SymbolTag uint32

const (
	// Render a symbol as obsolete, usually using a strike-out.
	SymbolTagDeprecated SymbolTag = 1
)

var validSymbolTagValues = map[uint32]bool{
	1: true,
}

func (s *SymbolTag) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validSymbolTagValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into SymbolTag: custom values are not supported", uint32Value)
	}
	*s = SymbolTag(uint32Value)

	return nil
}

func (s SymbolTag) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(s)
	if !validSymbolTagValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into SymbolTag: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

type WorkspaceSymbolClientCapabilitiesTagSupport struct {
	// The tags supported by the client.
	ValueSet []SymbolTag `json:"valueSet"`
}

type WorkspaceSymbolClientCapabilitiesResolveSupport struct {
	// The properties that a client can resolve lazily. Usually
	// `location.range`
	Properties []string `json:"properties"`
}

// Client capabilities for a {@link WorkspaceSymbolRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceSymbolClientCapabilities
type WorkspaceSymbolClientCapabilities struct {
	// Symbol request supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
	SymbolKind *WorkspaceSymbolClientCapabilitiesSymbolKind `json:"symbolKind,omitempty"`
	// The client supports tags on `SymbolInformation`.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// @since 3.16.0
	TagSupport *WorkspaceSymbolClientCapabilitiesTagSupport `json:"tagSupport,omitempty"`
	// The client support partial workspace symbols. The client will send the
	// request `workspaceSymbol/resolve` to the server to resolve additional
	// properties.
	//
	// @since 3.17.0
	ResolveSupport *WorkspaceSymbolClientCapabilitiesResolveSupport `json:"resolveSupport,omitempty"`
}

// The client capabilities of a {@link ExecuteCommandRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#executeCommandClientCapabilities
type ExecuteCommandClientCapabilities struct {
	// Execute command supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#semanticTokensWorkspaceClientCapabilities
type SemanticTokensWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// semantic tokens currently shown. It should be used with absolute care
	// and is useful for situation where a server for example detects a project
	// wide change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeLensWorkspaceClientCapabilities
type CodeLensWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// code lenses currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detect a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

// Capabilities relating to events from file operations by the user in the client.
//
// These events do not come from the file system, they come from user operations
// like renaming a file in the UI.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationClientCapabilities
type FileOperationClientCapabilities struct {
	// Whether the client supports dynamic registration for file requests/notifications.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client has support for sending didCreateFiles notifications.
	DidCreate bool `json:"didCreate,omitempty"`
	// The client has support for sending willCreateFiles requests.
	WillCreate bool `json:"willCreate,omitempty"`
	// The client has support for sending didRenameFiles notifications.
	DidRename bool `json:"didRename,omitempty"`
	// The client has support for sending willRenameFiles requests.
	WillRename bool `json:"willRename,omitempty"`
	// The client has support for sending didDeleteFiles notifications.
	DidDelete bool `json:"didDelete,omitempty"`
	// The client has support for sending willDeleteFiles requests.
	WillDelete bool `json:"willDelete,omitempty"`
}

// Client workspace capabilities specific to inline values.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlineValueWorkspaceClientCapabilities
type InlineValueWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// inline values currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

// Client workspace capabilities specific to inlay hints.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHintWorkspaceClientCapabilities
type InlayHintWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// inlay hints currently shown. It should be used with absolute care and
	// is useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

// Workspace client capabilities specific to diagnostic pull requests.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticWorkspaceClientCapabilities
type DiagnosticWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// pulled diagnostics currently shown. It should be used with absolute care and
	// is useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

// Client workspace capabilities specific to folding ranges
//
// @since 3.18.0
// @proposed
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#foldingRangeWorkspaceClientCapabilities
type FoldingRangeWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// folding ranges currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	//
	// @since 3.18.0
	// @proposed
	RefreshSupport bool `json:"refreshSupport,omitempty"`
}

// Workspace specific client capabilities.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceClientCapabilities
type WorkspaceClientCapabilities struct {
	// The client supports applying batch edits
	// to the workspace by supporting the request
	// 'workspace/applyEdit'
	ApplyEdit bool `json:"applyEdit,omitempty"`
	// Capabilities specific to `WorkspaceEdit`s.
	WorkspaceEdit *WorkspaceEditClientCapabilities `json:"workspaceEdit,omitempty"`
	// Capabilities specific to the `workspace/didChangeConfiguration` notification.
	DidChangeConfiguration *DidChangeConfigurationClientCapabilities `json:"didChangeConfiguration,omitempty"`
	// Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
	DidChangeWatchedFiles *DidChangeWatchedFilesClientCapabilities `json:"didChangeWatchedFiles,omitempty"`
	// Capabilities specific to the `workspace/symbol` request.
	Symbol *WorkspaceSymbolClientCapabilities `json:"symbol,omitempty"`
	// Capabilities specific to the `workspace/executeCommand` request.
	ExecuteCommand *ExecuteCommandClientCapabilities `json:"executeCommand,omitempty"`
	// The client has support for workspace folders.
	//
	// @since 3.6.0
	WorkspaceFolders bool `json:"workspaceFolders,omitempty"`
	// The client supports `workspace/configuration` requests.
	//
	// @since 3.6.0
	Configuration bool `json:"configuration,omitempty"`
	// Capabilities specific to the semantic token requests scoped to the
	// workspace.
	//
	// @since 3.16.0.
	SemanticTokens *SemanticTokensWorkspaceClientCapabilities `json:"semanticTokens,omitempty"`
	// Capabilities specific to the code lens requests scoped to the
	// workspace.
	//
	// @since 3.16.0.
	CodeLens *CodeLensWorkspaceClientCapabilities `json:"codeLens,omitempty"`
	// The client has support for file notifications/requests for user operations on files.
	//
	// Since 3.16.0
	FileOperations *FileOperationClientCapabilities `json:"fileOperations,omitempty"`
	// Capabilities specific to the inline values requests scoped to the
	// workspace.
	//
	// @since 3.17.0.
	InlineValue *InlineValueWorkspaceClientCapabilities `json:"inlineValue,omitempty"`
	// Capabilities specific to the inlay hint requests scoped to the
	// workspace.
	//
	// @since 3.17.0.
	InlayHint *InlayHintWorkspaceClientCapabilities `json:"inlayHint,omitempty"`
	// Capabilities specific to the diagnostic requests scoped to the
	// workspace.
	//
	// @since 3.17.0.
	Diagnostics *DiagnosticWorkspaceClientCapabilities `json:"diagnostics,omitempty"`
	// Capabilities specific to the folding range requests scoped to the workspace.
	//
	// @since 3.18.0
	// @proposed
	FoldingRange *FoldingRangeWorkspaceClientCapabilities `json:"foldingRange,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentSyncClientCapabilities
type TextDocumentSyncClientCapabilities struct {
	// Whether text document synchronization supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports sending will save notifications.
	WillSave bool `json:"willSave,omitempty"`
	// The client supports sending a will save request and
	// waits for a response providing text edits which will
	// be applied to the document before it is saved.
	WillSaveWaitUntil bool `json:"willSaveWaitUntil,omitempty"`
	// The client supports did save notifications.
	DidSave bool `json:"didSave,omitempty"`
}

// Describes the content type that a client supports in various
// result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
//
// Please note that `MarkupKinds` must not start with a `$`. This kinds
// are reserved for internal usage.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#markupKind
type MarkupKind string

const (
	// Plain text is supported as a content format
	MarkupKindPlainText MarkupKind = "plaintext"
	// Markdown is supported as a content format
	MarkupKindMarkdown MarkupKind = "markdown"
)

var validMarkupKindValues = map[string]bool{
	"plaintext": true,
	"markdown":  true,
}

func (m *MarkupKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue string
	if err := json.Unmarshal(data, &stringValue); err != nil {
		return err
	}
	if !validMarkupKindValues[stringValue] {
		return fmt.Errorf("cannot unmarshal %v into MarkupKind: custom values are not supported", stringValue)
	}
	*m = MarkupKind(stringValue)

	return nil
}

func (m MarkupKind) MarshalJSON() ([]byte, error) {
	var stringValue = string(m)
	if !validMarkupKindValues[stringValue] {
		return nil, fmt.Errorf("cannot marshal %v into MarkupKind: custom values are not supported", stringValue)
	}
	return json.Marshal(stringValue)

}

// Completion item tags are extra annotations that tweak the rendering of a completion
// item.
//
// @since 3.15.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItemTag
type CompletionItemTag uint32

const (
	// Render a completion as obsolete, usually using a strike-out.
	CompletionItemTagDeprecated CompletionItemTag = 1
)

var validCompletionItemTagValues = map[uint32]bool{
	1: true,
}

func (c *CompletionItemTag) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validCompletionItemTagValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into CompletionItemTag: custom values are not supported", uint32Value)
	}
	*c = CompletionItemTag(uint32Value)

	return nil
}

func (c CompletionItemTag) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(c)
	if !validCompletionItemTagValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into CompletionItemTag: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

type CompletionClientCapabilitiesCompletionItemTagSupport struct {
	// The tags supported by the client.
	ValueSet []CompletionItemTag `json:"valueSet"`
}

type CompletionClientCapabilitiesCompletionItemResolveSupport struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

// How whitespace and indentation is handled during completion
// item insertion.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#insertTextMode
type InsertTextMode uint32

const (
	// The insertion or replace strings is taken as it is. If the
	// value is multi line the lines below the cursor will be
	// inserted using the indentation defined in the string value.
	// The client will not apply any kind of adjustments to the
	// string.
	InsertTextModeasIs InsertTextMode = 1
	// The editor adjusts leading whitespace of new lines so that
	// they match the indentation up to the cursor of the line for
	// which the item is accepted.
	//
	// Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
	// multi line completion item is indented using 2 tabs and all
	// following lines inserted will be indented using 2 tabs as well.
	InsertTextModeadjustIndentation InsertTextMode = 2
)

var validInsertTextModeValues = map[uint32]bool{
	1: true,
	2: true,
}

func (i *InsertTextMode) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validInsertTextModeValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into InsertTextMode: custom values are not supported", uint32Value)
	}
	*i = InsertTextMode(uint32Value)

	return nil
}

func (i InsertTextMode) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(i)
	if !validInsertTextModeValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into InsertTextMode: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

type CompletionClientCapabilitiesCompletionItemInsertTextModeSupport struct {
	ValueSet []InsertTextMode `json:"valueSet"`
}

type CompletionClientCapabilitiesCompletionItem struct {
	// Client supports snippets as insert text.
	//
	// A snippet can define tab stops and placeholders with `$1`, `$2`
	// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
	// the end of the snippet. Placeholders with equal identifiers are linked,
	// that is typing in one will update others too.
	SnippetSupport bool `json:"snippetSupport,omitempty"`
	// Client supports commit characters on a completion item.
	CommitCharactersSupport bool `json:"commitCharactersSupport,omitempty"`
	// Client supports the following content formats for the documentation
	// property. The order describes the preferred format of the client.
	DocumentationFormat []MarkupKind `json:"documentationFormat,omitempty"`
	// Client supports the deprecated property on a completion item.
	DeprecatedSupport bool `json:"deprecatedSupport,omitempty"`
	// Client supports the preselect property on a completion item.
	PreselectSupport bool `json:"preselectSupport,omitempty"`
	// Client supports the tag property on a completion item. Clients supporting
	// tags have to handle unknown tags gracefully. Clients especially need to
	// preserve unknown tags when sending a completion item back to the server in
	// a resolve call.
	//
	// @since 3.15.0
	TagSupport *CompletionClientCapabilitiesCompletionItemTagSupport `json:"tagSupport,omitempty"`
	// Client support insert replace edit to control different behavior if a
	// completion item is inserted in the text or should replace text.
	//
	// @since 3.16.0
	InsertReplaceSupport bool `json:"insertReplaceSupport,omitempty"`
	// Indicates which properties a client can resolve lazily on a completion
	// item. Before version 3.16.0 only the predefined properties `documentation`
	// and `details` could be resolved lazily.
	//
	// @since 3.16.0
	ResolveSupport *CompletionClientCapabilitiesCompletionItemResolveSupport `json:"resolveSupport,omitempty"`
	// The client supports the `insertTextMode` property on
	// a completion item to override the whitespace handling mode
	// as defined by the client (see `insertTextMode`).
	//
	// @since 3.16.0
	InsertTextModeSupport *CompletionClientCapabilitiesCompletionItemInsertTextModeSupport `json:"insertTextModeSupport,omitempty"`
	// The client has support for completion item label
	// details (see also `CompletionItemLabelDetails`).
	//
	// @since 3.17.0
	LabelDetailsSupport bool `json:"labelDetailsSupport,omitempty"`
}

// The kind of a completion entry.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItemKind
type CompletionItemKind uint32

const (
	CompletionItemKindText          CompletionItemKind = 1
	CompletionItemKindMethod        CompletionItemKind = 2
	CompletionItemKindFunction      CompletionItemKind = 3
	CompletionItemKindConstructor   CompletionItemKind = 4
	CompletionItemKindField         CompletionItemKind = 5
	CompletionItemKindVariable      CompletionItemKind = 6
	CompletionItemKindClass         CompletionItemKind = 7
	CompletionItemKindInterface     CompletionItemKind = 8
	CompletionItemKindModule        CompletionItemKind = 9
	CompletionItemKindProperty      CompletionItemKind = 10
	CompletionItemKindUnit          CompletionItemKind = 11
	CompletionItemKindValue         CompletionItemKind = 12
	CompletionItemKindEnum          CompletionItemKind = 13
	CompletionItemKindKeyword       CompletionItemKind = 14
	CompletionItemKindSnippet       CompletionItemKind = 15
	CompletionItemKindColor         CompletionItemKind = 16
	CompletionItemKindFile          CompletionItemKind = 17
	CompletionItemKindReference     CompletionItemKind = 18
	CompletionItemKindFolder        CompletionItemKind = 19
	CompletionItemKindEnumMember    CompletionItemKind = 20
	CompletionItemKindConstant      CompletionItemKind = 21
	CompletionItemKindStruct        CompletionItemKind = 22
	CompletionItemKindEvent         CompletionItemKind = 23
	CompletionItemKindOperator      CompletionItemKind = 24
	CompletionItemKindTypeParameter CompletionItemKind = 25
)

var validCompletionItemKindValues = map[uint32]bool{
	1:  true,
	2:  true,
	3:  true,
	4:  true,
	5:  true,
	6:  true,
	7:  true,
	8:  true,
	9:  true,
	10: true,
	11: true,
	12: true,
	13: true,
	14: true,
	15: true,
	16: true,
	17: true,
	18: true,
	19: true,
	20: true,
	21: true,
	22: true,
	23: true,
	24: true,
	25: true,
}

func (c *CompletionItemKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validCompletionItemKindValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into CompletionItemKind: custom values are not supported", uint32Value)
	}
	*c = CompletionItemKind(uint32Value)

	return nil
}

func (c CompletionItemKind) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(c)
	if !validCompletionItemKindValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into CompletionItemKind: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

type CompletionClientCapabilitiesCompletionItemKind struct {
	// The completion item kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the completion items kinds from `Text` to `Reference` as defined in
	// the initial version of the protocol.
	ValueSet []CompletionItemKind `json:"valueSet,omitempty"`
}

type CompletionClientCapabilitiesCompletionList struct {
	// The client supports the following itemDefaults on
	// a completion list.
	//
	// The value lists the supported property names of the
	// `CompletionList.itemDefaults` object. If omitted
	// no properties are supported.
	//
	// @since 3.17.0
	ItemDefaults []string `json:"itemDefaults,omitempty"`
}

// Completion client capabilities
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionClientCapabilities
type CompletionClientCapabilities struct {
	// Whether completion supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports the following `CompletionItem` specific
	// capabilities.
	CompletionItem *CompletionClientCapabilitiesCompletionItem `json:"completionItem,omitempty"`

	CompletionItemKind *CompletionClientCapabilitiesCompletionItemKind `json:"completionItemKind,omitempty"`
	// Defines how the client handles whitespace and indentation
	// when accepting a completion item that uses multi line
	// text in either `insertText` or `textEdit`.
	//
	// @since 3.17.0
	InsertTextMode InsertTextMode `json:"insertTextMode,omitempty"`
	// The client supports to send additional context information for a
	// `textDocument/completion` request.
	ContextSupport bool `json:"contextSupport,omitempty"`
	// The client supports the following `CompletionList` specific
	// capabilities.
	//
	// @since 3.17.0
	CompletionList *CompletionClientCapabilitiesCompletionList `json:"completionList,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#hoverClientCapabilities
type HoverClientCapabilities struct {
	// Whether hover supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Client supports the following content formats for the content
	// property. The order describes the preferred format of the client.
	ContentFormat []MarkupKind `json:"contentFormat,omitempty"`
}

type SignatureHelpClientCapabilitiesSignatureInformationParameterInformation struct {
	// The client supports processing label offsets instead of a
	// simple label string.
	//
	// @since 3.14.0
	LabelOffsetSupport bool `json:"labelOffsetSupport,omitempty"`
}

type SignatureHelpClientCapabilitiesSignatureInformation struct {
	// Client supports the following content formats for the documentation
	// property. The order describes the preferred format of the client.
	DocumentationFormat []MarkupKind `json:"documentationFormat,omitempty"`
	// Client capabilities specific to parameter information.
	ParameterInformation *SignatureHelpClientCapabilitiesSignatureInformationParameterInformation `json:"parameterInformation,omitempty"`
	// The client supports the `activeParameter` property on `SignatureInformation`
	// literal.
	//
	// @since 3.16.0
	ActiveParameterSupport bool `json:"activeParameterSupport,omitempty"`
}

// Client Capabilities for a {@link SignatureHelpRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#signatureHelpClientCapabilities
type SignatureHelpClientCapabilities struct {
	// Whether signature help supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports the following `SignatureInformation`
	// specific properties.
	SignatureInformation *SignatureHelpClientCapabilitiesSignatureInformation `json:"signatureInformation,omitempty"`
	// The client supports to send additional context information for a
	// `textDocument/signatureHelp` request. A client that opts into
	// contextSupport will also support the `retriggerCharacters` on
	// `SignatureHelpOptions`.
	//
	// @since 3.15.0
	ContextSupport bool `json:"contextSupport,omitempty"`
}

// @since 3.14.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#declarationClientCapabilities
type DeclarationClientCapabilities struct {
	// Whether declaration supports dynamic registration. If this is set to `true`
	// the client supports the new `DeclarationRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of declaration links.
	LinkSupport bool `json:"linkSupport,omitempty"`
}

// Client Capabilities for a {@link DefinitionRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#definitionClientCapabilities
type DefinitionClientCapabilities struct {
	// Whether definition supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of definition links.
	//
	// @since 3.14.0
	LinkSupport bool `json:"linkSupport,omitempty"`
}

// Since 3.6.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#typeDefinitionClientCapabilities
type TypeDefinitionClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `TypeDefinitionRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of definition links.
	//
	// Since 3.14.0
	LinkSupport bool `json:"linkSupport,omitempty"`
}

// @since 3.6.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#implementationClientCapabilities
type ImplementationClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `ImplementationRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports additional metadata in the form of definition links.
	//
	// @since 3.14.0
	LinkSupport bool `json:"linkSupport,omitempty"`
}

// Client Capabilities for a {@link ReferencesRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#referenceClientCapabilities
type ReferenceClientCapabilities struct {
	// Whether references supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// Client Capabilities for a {@link DocumentHighlightRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentHighlightClientCapabilities
type DocumentHighlightClientCapabilities struct {
	// Whether document highlight supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

type DocumentSymbolClientCapabilitiesSymbolKind struct {
	// The symbol kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the symbol kinds from `File` to `Array` as defined in
	// the initial version of the protocol.
	ValueSet []SymbolKind `json:"valueSet,omitempty"`
}

type DocumentSymbolClientCapabilitiesTagSupport struct {
	// The tags supported by the client.
	ValueSet []SymbolTag `json:"valueSet"`
}

// Client Capabilities for a {@link DocumentSymbolRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentSymbolClientCapabilities
type DocumentSymbolClientCapabilities struct {
	// Whether document symbol supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Specific capabilities for the `SymbolKind` in the
	// `textDocument/documentSymbol` request.
	SymbolKind *DocumentSymbolClientCapabilitiesSymbolKind `json:"symbolKind,omitempty"`
	// The client supports hierarchical document symbols.
	HierarchicalDocumentSymbolSupport bool `json:"hierarchicalDocumentSymbolSupport,omitempty"`
	// The client supports tags on `SymbolInformation`. Tags are supported on
	// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// @since 3.16.0
	TagSupport *DocumentSymbolClientCapabilitiesTagSupport `json:"tagSupport,omitempty"`
	// The client supports an additional label presented in the UI when
	// registering a document symbol provider.
	//
	// @since 3.16.0
	LabelSupport bool `json:"labelSupport,omitempty"`
}

// A set of predefined code action kinds
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionKind
type CodeActionKind string

const (
	// Empty kind.
	CodeActionKindEmpty CodeActionKind = ""
	// Base kind for quickfix actions: 'quickfix'
	CodeActionKindQuickFix CodeActionKind = "quickfix"
	// Base kind for refactoring actions: 'refactor'
	CodeActionKindRefactor CodeActionKind = "refactor"
	// Base kind for refactoring extraction actions: 'refactor.extract'
	//
	// Example extract actions:
	//
	// - Extract method
	// - Extract function
	// - Extract variable
	// - Extract interface from class
	// - ...
	CodeActionKindRefactorExtract CodeActionKind = "refactor.extract"
	// Base kind for refactoring inline actions: 'refactor.inline'
	//
	// Example inline actions:
	//
	// - Inline function
	// - Inline variable
	// - Inline constant
	// - ...
	CodeActionKindRefactorInline CodeActionKind = "refactor.inline"
	// Base kind for refactoring rewrite actions: 'refactor.rewrite'
	//
	// Example rewrite actions:
	//
	// - Convert JavaScript function to class
	// - Add or remove parameter
	// - Encapsulate field
	// - Make method static
	// - Move method to base class
	// - ...
	CodeActionKindRefactorRewrite CodeActionKind = "refactor.rewrite"
	// Base kind for source actions: `source`
	//
	// Source code actions apply to the entire file.
	CodeActionKindSource CodeActionKind = "source"
	// Base kind for an organize imports source action: `source.organizeImports`
	CodeActionKindSourceOrganizeImports CodeActionKind = "source.organizeImports"
	// Base kind for auto-fix source actions: `source.fixAll`.
	//
	// Fix all actions automatically fix errors that have a clear fix that do not require user input.
	// They should not suppress errors or perform unsafe fixes such as generating new types or classes.
	//
	// @since 3.15.0
	CodeActionKindSourceFixAll CodeActionKind = "source.fixAll"
)

type CodeActionClientCapabilitiesCodeActionLiteralSupportCodeActionKind struct {
	// The code action kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	ValueSet []CodeActionKind `json:"valueSet"`
}

type CodeActionClientCapabilitiesCodeActionLiteralSupport struct {
	// The code action kind is support with the following value
	// set.
	CodeActionKind *CodeActionClientCapabilitiesCodeActionLiteralSupportCodeActionKind `json:"codeActionKind"`
}

type CodeActionClientCapabilitiesResolveSupport struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

// The Client Capabilities of a {@link CodeActionRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionClientCapabilities
type CodeActionClientCapabilities struct {
	// Whether code action supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client support code action literals of type `CodeAction` as a valid
	// response of the `textDocument/codeAction` request. If the property is not
	// set the request can only return `Command` literals.
	//
	// @since 3.8.0
	CodeActionLiteralSupport *CodeActionClientCapabilitiesCodeActionLiteralSupport `json:"codeActionLiteralSupport,omitempty"`
	// Whether code action supports the `isPreferred` property.
	//
	// @since 3.15.0
	IsPreferredSupport bool `json:"isPreferredSupport,omitempty"`
	// Whether code action supports the `disabled` property.
	//
	// @since 3.16.0
	DisabledSupport bool `json:"disabledSupport,omitempty"`
	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/codeAction` and a
	// `codeAction/resolve` request.
	//
	// @since 3.16.0
	DataSupport bool `json:"dataSupport,omitempty"`
	// Whether the client supports resolving additional code action
	// properties via a separate `codeAction/resolve` request.
	//
	// @since 3.16.0
	ResolveSupport *CodeActionClientCapabilitiesResolveSupport `json:"resolveSupport,omitempty"`
	// Whether the client honors the change annotations in
	// text edits and resource operations returned via the
	// `CodeAction#edit` property by for example presenting
	// the workspace edit in the user interface and asking
	// for confirmation.
	//
	// @since 3.16.0
	HonorsChangeAnnotations bool `json:"honorsChangeAnnotations,omitempty"`
}

// The client capabilities  of a {@link CodeLensRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeLensClientCapabilities
type CodeLensClientCapabilities struct {
	// Whether code lens supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// The client capabilities of a {@link DocumentLinkRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentLinkClientCapabilities
type DocumentLinkClientCapabilities struct {
	// Whether document link supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the client supports the `tooltip` property on `DocumentLink`.
	//
	// @since 3.15.0
	TooltipSupport bool `json:"tooltipSupport,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentColorClientCapabilities
type DocumentColorClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `DocumentColorRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// Client capabilities of a {@link DocumentFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentFormattingClientCapabilities
type DocumentFormattingClientCapabilities struct {
	// Whether formatting supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// Client capabilities of a {@link DocumentRangeFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentRangeFormattingClientCapabilities
type DocumentRangeFormattingClientCapabilities struct {
	// Whether range formatting supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the client supports formatting multiple ranges at once.
	//
	// @since 3.18.0
	// @proposed
	RangesSupport bool `json:"rangesSupport,omitempty"`
}

// Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentOnTypeFormattingClientCapabilities
type DocumentOnTypeFormattingClientCapabilities struct {
	// Whether on type formatting supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#prepareSupportDefaultBehavior
type PrepareSupportDefaultBehavior uint32

const (
	// The client's default behavior is to select the identifier
	// according the to language's syntax rule.
	PrepareSupportDefaultBehaviorIdentifier PrepareSupportDefaultBehavior = 1
)

var validPrepareSupportDefaultBehaviorValues = map[uint32]bool{
	1: true,
}

func (p *PrepareSupportDefaultBehavior) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validPrepareSupportDefaultBehaviorValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into PrepareSupportDefaultBehavior: custom values are not supported", uint32Value)
	}
	*p = PrepareSupportDefaultBehavior(uint32Value)

	return nil
}

func (p PrepareSupportDefaultBehavior) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(p)
	if !validPrepareSupportDefaultBehaviorValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into PrepareSupportDefaultBehavior: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#renameClientCapabilities
type RenameClientCapabilities struct {
	// Whether rename supports dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Client supports testing for validity of rename operations
	// before execution.
	//
	// @since 3.12.0
	PrepareSupport bool `json:"prepareSupport,omitempty"`
	// Client supports the default behavior result.
	//
	// The value indicates the default behavior used by the
	// client.
	//
	// @since 3.16.0
	PrepareSupportDefaultBehavior PrepareSupportDefaultBehavior `json:"prepareSupportDefaultBehavior,omitempty"`
	// Whether the client honors the change annotations in
	// text edits and resource operations returned via the
	// rename request's workspace edit by for example presenting
	// the workspace edit in the user interface and asking
	// for confirmation.
	//
	// @since 3.16.0
	HonorsChangeAnnotations bool `json:"honorsChangeAnnotations,omitempty"`
}

// A set of predefined range kinds.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#foldingRangeKind
type FoldingRangeKind string

const (
	// Folding range for a comment
	FoldingRangeKindComment FoldingRangeKind = "comment"
	// Folding range for an import or include
	FoldingRangeKindImports FoldingRangeKind = "imports"
	// Folding range for a region (e.g. `#region`)
	FoldingRangeKindRegion FoldingRangeKind = "region"
)

type FoldingRangeClientCapabilitiesFoldingRangeKind struct {
	// The folding range kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	ValueSet []FoldingRangeKind `json:"valueSet,omitempty"`
}

type FoldingRangeClientCapabilitiesFoldingRange struct {
	// If set, the client signals that it supports setting collapsedText on
	// folding ranges to display custom labels instead of the default text.
	//
	// @since 3.17.0
	CollapsedText bool `json:"collapsedText,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#foldingRangeClientCapabilities
type FoldingRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration for folding range
	// providers. If this is set to `true` the client supports the new
	// `FoldingRangeRegistrationOptions` return value for the corresponding
	// server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The maximum number of folding ranges that the client prefers to receive
	// per document. The value serves as a hint, servers are free to follow the
	// limit.
	RangeLimit int `json:"rangeLimit,omitempty"`
	// If set, the client signals that it only supports folding complete lines.
	// If set, client will ignore specified `startCharacter` and `endCharacter`
	// properties in a FoldingRange.
	LineFoldingOnly bool `json:"lineFoldingOnly,omitempty"`
	// Specific options for the folding range kind.
	//
	// @since 3.17.0
	FoldingRangeKind *FoldingRangeClientCapabilitiesFoldingRangeKind `json:"foldingRangeKind,omitempty"`
	// Specific options for the folding range.
	//
	// @since 3.17.0
	FoldingRange *FoldingRangeClientCapabilitiesFoldingRange `json:"foldingRange,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#selectionRangeClientCapabilities
type SelectionRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
	// the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
	// capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// The diagnostic tags.
//
// @since 3.15.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticTag
type DiagnosticTag uint32

const (
	// Unused or unnecessary code.
	//
	// Clients are allowed to render diagnostics with this tag faded out instead of having
	// an error squiggle.
	DiagnosticTagUnnecessary DiagnosticTag = 1
	// Deprecated or obsolete code.
	//
	// Clients are allowed to rendered diagnostics with this tag strike through.
	DiagnosticTagDeprecated DiagnosticTag = 2
)

var validDiagnosticTagValues = map[uint32]bool{
	1: true,
	2: true,
}

func (d *DiagnosticTag) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validDiagnosticTagValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into DiagnosticTag: custom values are not supported", uint32Value)
	}
	*d = DiagnosticTag(uint32Value)

	return nil
}

func (d DiagnosticTag) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(d)
	if !validDiagnosticTagValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into DiagnosticTag: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

type PublishDiagnosticsClientCapabilitiesTagSupport struct {
	// The tags supported by the client.
	ValueSet []DiagnosticTag `json:"valueSet"`
}

// The publish diagnostic client capabilities.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#publishDiagnosticsClientCapabilities
type PublishDiagnosticsClientCapabilities struct {
	// Whether the clients accepts diagnostics with related information.
	RelatedInformation bool `json:"relatedInformation,omitempty"`
	// Client supports the tag property to provide meta data about a diagnostic.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// @since 3.15.0
	TagSupport *PublishDiagnosticsClientCapabilitiesTagSupport `json:"tagSupport,omitempty"`
	// Whether the client interprets the version property of the
	// `textDocument/publishDiagnostics` notification's parameter.
	//
	// @since 3.15.0
	VersionSupport bool `json:"versionSupport,omitempty"`
	// Client supports a codeDescription property
	//
	// @since 3.16.0
	CodeDescriptionSupport bool `json:"codeDescriptionSupport,omitempty"`
	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/publishDiagnostics` and
	// `textDocument/codeAction` request.
	//
	// @since 3.16.0
	DataSupport bool `json:"dataSupport,omitempty"`
}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#callHierarchyClientCapabilities
type CallHierarchyClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

type Boolean bool

type SemanticTokensClientCapabilitiesRequestsRangeOr2 struct {
}

// BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2 contains either of the following types:
//   - [Boolean]
//   - [*SemanticTokensClientCapabilitiesRequestsRangeOr2]
type BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2 struct {
	Value BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value
}

// BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value is either of the following types:
//   - [Boolean]
//   - [*SemanticTokensClientCapabilitiesRequestsRangeOr2]
//
//gosumtype:decl BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value
type BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value interface {
	isBooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value()
}

func (Boolean) isBooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value() {}
func (*SemanticTokensClientCapabilitiesRequestsRangeOr2) isBooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2Value() {
}

func (b *BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var semanticTokensClientCapabilitiesRequestsRangeOr2Value *SemanticTokensClientCapabilitiesRequestsRangeOr2
	if err := json.Unmarshal(data, &semanticTokensClientCapabilitiesRequestsRangeOr2Value); err == nil {
		b.Value = semanticTokensClientCapabilitiesRequestsRangeOr2Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2](),
	}
}

func (b BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

type SemanticTokensClientCapabilitiesRequestsFullOr2 struct {
	// The client will send the `textDocument/semanticTokens/full/delta` request if
	// the server provides a corresponding handler.
	Delta bool `json:"delta,omitempty"`
}

// BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2 contains either of the following types:
//   - [Boolean]
//   - [*SemanticTokensClientCapabilitiesRequestsFullOr2]
type BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2 struct {
	Value BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value
}

// BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value is either of the following types:
//   - [Boolean]
//   - [*SemanticTokensClientCapabilitiesRequestsFullOr2]
//
//gosumtype:decl BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value
type BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value interface {
	isBooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value()
}

func (Boolean) isBooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value() {}
func (*SemanticTokensClientCapabilitiesRequestsFullOr2) isBooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2Value() {
}

func (b *BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var semanticTokensClientCapabilitiesRequestsFullOr2Value *SemanticTokensClientCapabilitiesRequestsFullOr2
	if err := json.Unmarshal(data, &semanticTokensClientCapabilitiesRequestsFullOr2Value); err == nil {
		b.Value = semanticTokensClientCapabilitiesRequestsFullOr2Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2](),
	}
}

func (b BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

type SemanticTokensClientCapabilitiesRequests struct {
	// The client will send the `textDocument/semanticTokens/range` request if
	// the server provides a corresponding handler.
	Range *BooleanOrSemanticTokensClientCapabilitiesRequestsRangeOr2 `json:"range,omitempty"`
	// The client will send the `textDocument/semanticTokens/full` request if
	// the server provides a corresponding handler.
	Full *BooleanOrSemanticTokensClientCapabilitiesRequestsFullOr2 `json:"full,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#tokenFormat
type TokenFormat string

const (
	TokenFormatRelative TokenFormat = "relative"
)

var validTokenFormatValues = map[string]bool{
	"relative": true,
}

func (t *TokenFormat) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue string
	if err := json.Unmarshal(data, &stringValue); err != nil {
		return err
	}
	if !validTokenFormatValues[stringValue] {
		return fmt.Errorf("cannot unmarshal %v into TokenFormat: custom values are not supported", stringValue)
	}
	*t = TokenFormat(stringValue)

	return nil
}

func (t TokenFormat) MarshalJSON() ([]byte, error) {
	var stringValue = string(t)
	if !validTokenFormatValues[stringValue] {
		return nil, fmt.Errorf("cannot marshal %v into TokenFormat: custom values are not supported", stringValue)
	}
	return json.Marshal(stringValue)

}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#semanticTokensClientCapabilities
type SemanticTokensClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Which requests the client supports and might send to the server
	// depending on the server's capability. Please note that clients might not
	// show semantic tokens or degrade some of the user experience if a range
	// or full request is advertised by the client but not provided by the
	// server. If for example the client capability `requests.full` and
	// `request.range` are both set to true but the server only provides a
	// range provider the client might not render a minimap correctly or might
	// even decide to not show any semantic tokens at all.
	Requests *SemanticTokensClientCapabilitiesRequests `json:"requests"`
	// The token types that the client supports.
	TokenTypes []string `json:"tokenTypes"`
	// The token modifiers that the client supports.
	TokenModifiers []string `json:"tokenModifiers"`
	// The token formats the clients supports.
	Formats []TokenFormat `json:"formats"`
	// Whether the client supports tokens that can overlap each other.
	OverlappingTokenSupport bool `json:"overlappingTokenSupport,omitempty"`
	// Whether the client supports tokens that can span multiple lines.
	MultilineTokenSupport bool `json:"multilineTokenSupport,omitempty"`
	// Whether the client allows the server to actively cancel a
	// semantic token request, e.g. supports returning
	// LSPErrorCodes.ServerCancelled. If a server does the client
	// needs to retrigger the request.
	//
	// @since 3.17.0
	ServerCancelSupport bool `json:"serverCancelSupport,omitempty"`
	// Whether the client uses semantic tokens to augment existing
	// syntax tokens. If set to `true` client side created syntax
	// tokens and semantic tokens are both used for colorization. If
	// set to `false` the client only uses the returned semantic tokens
	// for colorization.
	//
	// If the value is `undefined` then the client behavior is not
	// specified.
	//
	// @since 3.17.0
	AugmentsSyntaxTokens bool `json:"augmentsSyntaxTokens,omitempty"`
}

// Client capabilities for the linked editing range request.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#linkedEditingRangeClientCapabilities
type LinkedEditingRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// Client capabilities specific to the moniker request.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#monikerClientCapabilities
type MonikerClientCapabilities struct {
	// Whether moniker supports dynamic registration. If this is set to `true`
	// the client supports the new `MonikerRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#typeHierarchyClientCapabilities
type TypeHierarchyClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// Client capabilities specific to inline values.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlineValueClientCapabilities
type InlineValueClientCapabilities struct {
	// Whether implementation supports dynamic registration for inline value providers.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

type InlayHintClientCapabilitiesResolveSupport struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

// Inlay hint client capabilities.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHintClientCapabilities
type InlayHintClientCapabilities struct {
	// Whether inlay hints support dynamic registration.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Indicates which properties a client can resolve lazily on an inlay
	// hint.
	ResolveSupport *InlayHintClientCapabilitiesResolveSupport `json:"resolveSupport,omitempty"`
}

// Client capabilities specific to diagnostic pull requests.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticClientCapabilities
type DiagnosticClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// Whether the clients supports related documents for document diagnostic pulls.
	RelatedDocumentSupport bool `json:"relatedDocumentSupport,omitempty"`
}

// Client capabilities specific to inline completions.
//
// @since 3.18.0
// @proposed
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlineCompletionClientCapabilities
type InlineCompletionClientCapabilities struct {
	// Whether implementation supports dynamic registration for inline completion providers.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
}

// Text document specific client capabilities.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentClientCapabilities
type TextDocumentClientCapabilities struct {
	// Defines which synchronization capabilities the client supports.
	Synchronization *TextDocumentSyncClientCapabilities `json:"synchronization,omitempty"`
	// Capabilities specific to the `textDocument/completion` request.
	Completion *CompletionClientCapabilities `json:"completion,omitempty"`
	// Capabilities specific to the `textDocument/hover` request.
	Hover *HoverClientCapabilities `json:"hover,omitempty"`
	// Capabilities specific to the `textDocument/signatureHelp` request.
	SignatureHelp *SignatureHelpClientCapabilities `json:"signatureHelp,omitempty"`
	// Capabilities specific to the `textDocument/declaration` request.
	//
	// @since 3.14.0
	Declaration *DeclarationClientCapabilities `json:"declaration,omitempty"`
	// Capabilities specific to the `textDocument/definition` request.
	Definition *DefinitionClientCapabilities `json:"definition,omitempty"`
	// Capabilities specific to the `textDocument/typeDefinition` request.
	//
	// @since 3.6.0
	TypeDefinition *TypeDefinitionClientCapabilities `json:"typeDefinition,omitempty"`
	// Capabilities specific to the `textDocument/implementation` request.
	//
	// @since 3.6.0
	Implementation *ImplementationClientCapabilities `json:"implementation,omitempty"`
	// Capabilities specific to the `textDocument/references` request.
	References *ReferenceClientCapabilities `json:"references,omitempty"`
	// Capabilities specific to the `textDocument/documentHighlight` request.
	DocumentHighlight *DocumentHighlightClientCapabilities `json:"documentHighlight,omitempty"`
	// Capabilities specific to the `textDocument/documentSymbol` request.
	DocumentSymbol *DocumentSymbolClientCapabilities `json:"documentSymbol,omitempty"`
	// Capabilities specific to the `textDocument/codeAction` request.
	CodeAction *CodeActionClientCapabilities `json:"codeAction,omitempty"`
	// Capabilities specific to the `textDocument/codeLens` request.
	CodeLens *CodeLensClientCapabilities `json:"codeLens,omitempty"`
	// Capabilities specific to the `textDocument/documentLink` request.
	DocumentLink *DocumentLinkClientCapabilities `json:"documentLink,omitempty"`
	// Capabilities specific to the `textDocument/documentColor` and the
	// `textDocument/colorPresentation` request.
	//
	// @since 3.6.0
	ColorProvider *DocumentColorClientCapabilities `json:"colorProvider,omitempty"`
	// Capabilities specific to the `textDocument/formatting` request.
	Formatting *DocumentFormattingClientCapabilities `json:"formatting,omitempty"`
	// Capabilities specific to the `textDocument/rangeFormatting` request.
	RangeFormatting *DocumentRangeFormattingClientCapabilities `json:"rangeFormatting,omitempty"`
	// Capabilities specific to the `textDocument/onTypeFormatting` request.
	OnTypeFormatting *DocumentOnTypeFormattingClientCapabilities `json:"onTypeFormatting,omitempty"`
	// Capabilities specific to the `textDocument/rename` request.
	Rename *RenameClientCapabilities `json:"rename,omitempty"`
	// Capabilities specific to the `textDocument/foldingRange` request.
	//
	// @since 3.10.0
	FoldingRange *FoldingRangeClientCapabilities `json:"foldingRange,omitempty"`
	// Capabilities specific to the `textDocument/selectionRange` request.
	//
	// @since 3.15.0
	SelectionRange *SelectionRangeClientCapabilities `json:"selectionRange,omitempty"`
	// Capabilities specific to the `textDocument/publishDiagnostics` notification.
	PublishDiagnostics *PublishDiagnosticsClientCapabilities `json:"publishDiagnostics,omitempty"`
	// Capabilities specific to the various call hierarchy requests.
	//
	// @since 3.16.0
	CallHierarchy *CallHierarchyClientCapabilities `json:"callHierarchy,omitempty"`
	// Capabilities specific to the various semantic token request.
	//
	// @since 3.16.0
	SemanticTokens *SemanticTokensClientCapabilities `json:"semanticTokens,omitempty"`
	// Capabilities specific to the `textDocument/linkedEditingRange` request.
	//
	// @since 3.16.0
	LinkedEditingRange *LinkedEditingRangeClientCapabilities `json:"linkedEditingRange,omitempty"`
	// Client capabilities specific to the `textDocument/moniker` request.
	//
	// @since 3.16.0
	Moniker *MonikerClientCapabilities `json:"moniker,omitempty"`
	// Capabilities specific to the various type hierarchy requests.
	//
	// @since 3.17.0
	TypeHierarchy *TypeHierarchyClientCapabilities `json:"typeHierarchy,omitempty"`
	// Capabilities specific to the `textDocument/inlineValue` request.
	//
	// @since 3.17.0
	InlineValue *InlineValueClientCapabilities `json:"inlineValue,omitempty"`
	// Capabilities specific to the `textDocument/inlayHint` request.
	//
	// @since 3.17.0
	InlayHint *InlayHintClientCapabilities `json:"inlayHint,omitempty"`
	// Capabilities specific to the diagnostic pull model.
	//
	// @since 3.17.0
	Diagnostic *DiagnosticClientCapabilities `json:"diagnostic,omitempty"`
	// Client capabilities specific to inline completions.
	//
	// @since 3.18.0
	// @proposed
	InlineCompletion *InlineCompletionClientCapabilities `json:"inlineCompletion,omitempty"`
}

// Notebook specific client capabilities.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocumentSyncClientCapabilities
type NotebookDocumentSyncClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is
	// set to `true` the client supports the new
	// `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration bool `json:"dynamicRegistration,omitempty"`
	// The client supports sending execution summary data per cell.
	ExecutionSummarySupport bool `json:"executionSummarySupport,omitempty"`
}

// Capabilities specific to the notebook document support.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocumentClientCapabilities
type NotebookDocumentClientCapabilities struct {
	// Capabilities specific to notebook document synchronization
	//
	// @since 3.17.0
	Synchronization *NotebookDocumentSyncClientCapabilities `json:"synchronization"`
}

type ShowMessageRequestClientCapabilitiesMessageActionItem struct {
	// Whether the client supports additional attributes which
	// are preserved and send back to the server in the
	// request's response.
	AdditionalPropertiesSupport bool `json:"additionalPropertiesSupport,omitempty"`
}

// Show message request client capabilities
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#showMessageRequestClientCapabilities
type ShowMessageRequestClientCapabilities struct {
	// Capabilities specific to the `MessageActionItem` type.
	MessageActionItem *ShowMessageRequestClientCapabilitiesMessageActionItem `json:"messageActionItem,omitempty"`
}

// Client capabilities for the showDocument request.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#showDocumentClientCapabilities
type ShowDocumentClientCapabilities struct {
	// The client has support for the showDocument
	// request.
	Support bool `json:"support"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#windowClientCapabilities
type WindowClientCapabilities struct {
	// It indicates whether the client supports server initiated
	// progress using the `window/workDoneProgress/create` request.
	//
	// The capability also controls Whether client supports handling
	// of progress notifications. If set servers are allowed to report a
	// `workDoneProgress` property in the request specific server
	// capabilities.
	//
	// @since 3.15.0
	WorkDoneProgress bool `json:"workDoneProgress,omitempty"`
	// Capabilities specific to the showMessage request.
	//
	// @since 3.16.0
	ShowMessage *ShowMessageRequestClientCapabilities `json:"showMessage,omitempty"`
	// Capabilities specific to the showDocument request.
	//
	// @since 3.16.0
	ShowDocument *ShowDocumentClientCapabilities `json:"showDocument,omitempty"`
}

type GeneralClientCapabilitiesStaleRequestSupport struct {
	// The client will actively cancel the request.
	Cancel bool `json:"cancel"`
	// The list of requests for which the client
	// will retry the request if it receives a
	// response with error code `ContentModified`
	RetryOnContentModified []string `json:"retryOnContentModified"`
}

// Client capabilities specific to regular expressions.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#regularExpressionsClientCapabilities
type RegularExpressionsClientCapabilities struct {
	// The engine's name.
	Engine string `json:"engine"`
	// The engine's version.
	Version string `json:"version,omitempty"`
}

// Client capabilities specific to the used markdown parser.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#markdownClientCapabilities
type MarkdownClientCapabilities struct {
	// The name of the parser.
	Parser string `json:"parser"`
	// The version of the parser.
	Version string `json:"version,omitempty"`
	// A list of HTML tags that the client allows / supports in
	// Markdown.
	//
	// @since 3.17.0
	AllowedTags []string `json:"allowedTags,omitempty"`
}

// A set of predefined position encoding kinds.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#positionEncodingKind
type PositionEncodingKind string

const (
	// Character offsets count UTF-8 code units (e.g. bytes).
	PositionEncodingKindUTF8 PositionEncodingKind = "utf-8"
	// Character offsets count UTF-16 code units.
	//
	// This is the default and must always be supported
	// by servers
	PositionEncodingKindUTF16 PositionEncodingKind = "utf-16"
	// Character offsets count UTF-32 code units.
	//
	// Implementation note: these are the same as Unicode codepoints,
	// so this `PositionEncodingKind` may also be used for an
	// encoding-agnostic representation of character offsets.
	PositionEncodingKindUTF32 PositionEncodingKind = "utf-32"
)

// General client capabilities.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#generalClientCapabilities
type GeneralClientCapabilities struct {
	// Client capability that signals how the client
	// handles stale requests (e.g. a request
	// for which the client will not process the response
	// anymore since the information is outdated).
	//
	// @since 3.17.0
	StaleRequestSupport *GeneralClientCapabilitiesStaleRequestSupport `json:"staleRequestSupport,omitempty"`
	// Client capabilities specific to regular expressions.
	//
	// @since 3.16.0
	RegularExpressions *RegularExpressionsClientCapabilities `json:"regularExpressions,omitempty"`
	// Client capabilities specific to the client's markdown parser.
	//
	// @since 3.16.0
	Markdown *MarkdownClientCapabilities `json:"markdown,omitempty"`
	// The position encodings supported by the client. Client and server
	// have to agree on the same position encoding to ensure that offsets
	// (e.g. character position in a line) are interpreted the same on both
	// sides.
	//
	// To keep the protocol backwards compatible the following applies: if
	// the value 'utf-16' is missing from the array of position encodings
	// servers can assume that the client supports UTF-16. UTF-16 is
	// therefore a mandatory encoding.
	//
	// If omitted it defaults to ['utf-16'].
	//
	// Implementation considerations: since the conversion from one encoding
	// into another requires the content of the file / line the conversion
	// is best done where the file is read which is usually on the server
	// side.
	//
	// @since 3.17.0
	PositionEncodings []PositionEncodingKind `json:"positionEncodings,omitempty"`
}

type stringLSPAnyMap map[string]LSPAny

// LSP object definition.
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#lSPObject
type LSPObject = stringLSPAnyMap

type LSPAnySlice []LSPAny

// LSP arrays.
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#lSPArray
type LSPArray = LSPAnySlice

type Uinteger int

type Decimal float64

// LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBoolean contains either of the following types:
//   - [LSPObject]
//   - [LSPArray]
//   - [String]
//   - [Integer]
//   - [Uinteger]
//   - [Decimal]
//   - [Boolean]
type LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBoolean struct {
	Value LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue
}

// LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue is either of the following types:
//   - [LSPObject]
//   - [LSPArray]
//   - [String]
//   - [Integer]
//   - [Uinteger]
//   - [Decimal]
//   - [Boolean]
//
//gosumtype:decl LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue
type LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue interface {
	isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()
}

func (LSPObject) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue() {}
func (LSPArray) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()  {}
func (String) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()    {}
func (Integer) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()   {}
func (Uinteger) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()  {}
func (Decimal) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()   {}
func (Boolean) isLSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBooleanValue()   {}

func (l *LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBoolean) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var lSPObjectValue LSPObject
	if err := json.Unmarshal(data, &lSPObjectValue); err == nil {
		l.Value = lSPObjectValue
		return nil
	}
	var lSPArrayValue LSPArray
	if err := json.Unmarshal(data, &lSPArrayValue); err == nil {
		l.Value = lSPArrayValue
		return nil
	}
	var stringValue String
	if err := json.Unmarshal(data, &stringValue); err == nil {
		l.Value = stringValue
		return nil
	}
	var integerValue Integer
	if err := json.Unmarshal(data, &integerValue); err == nil {
		l.Value = integerValue
		return nil
	}
	var uintegerValue Uinteger
	if err := json.Unmarshal(data, &uintegerValue); err == nil {
		l.Value = uintegerValue
		return nil
	}
	var decimalValue Decimal
	if err := json.Unmarshal(data, &decimalValue); err == nil {
		l.Value = decimalValue
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		l.Value = booleanValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBoolean](),
	}
}

func (l LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBoolean) MarshalJSON() ([]byte, error) {
	return json.Marshal(l.Value)
}

// The LSP any type.
// Please note that strictly speaking a property with the value `undefined`
// can't be converted into JSON preserving the property name. However for
// convenience it is allowed and assumed that all these properties are
// optional as well.
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#lSPAny
type LSPAny = *LSPObjectOrLSPArrayOrStringOrIntegerOrUintegerOrDecimalOrBoolean

// Defines the capabilities provided by the client.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#clientCapabilities
type ClientCapabilities struct {
	// Workspace specific client capabilities.
	Workspace *WorkspaceClientCapabilities `json:"workspace,omitempty"`
	// Text document specific client capabilities.
	TextDocument *TextDocumentClientCapabilities `json:"textDocument,omitempty"`
	// Capabilities specific to the notebook document support.
	//
	// @since 3.17.0
	NotebookDocument *NotebookDocumentClientCapabilities `json:"notebookDocument,omitempty"`
	// Window specific client capabilities.
	Window *WindowClientCapabilities `json:"window,omitempty"`
	// General client capabilities.
	//
	// @since 3.16.0
	General *GeneralClientCapabilities `json:"general,omitempty"`
	// Experimental client capabilities.
	Experimental LSPAny `json:"experimental,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#traceValues
type TraceValues string

const (
	// Turn tracing off.
	TraceValuesOff TraceValues = "off"
	// Trace messages only.
	TraceValuesMessages TraceValues = "messages"
	// Verbose message tracing.
	TraceValuesVerbose TraceValues = "verbose"
)

var validTraceValuesValues = map[string]bool{
	"off":      true,
	"messages": true,
	"verbose":  true,
}

func (t *TraceValues) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue string
	if err := json.Unmarshal(data, &stringValue); err != nil {
		return err
	}
	if !validTraceValuesValues[stringValue] {
		return fmt.Errorf("cannot unmarshal %v into TraceValues: custom values are not supported", stringValue)
	}
	*t = TraceValues(stringValue)

	return nil
}

func (t TraceValues) MarshalJSON() ([]byte, error) {
	var stringValue = string(t)
	if !validTraceValuesValues[stringValue] {
		return nil, fmt.Errorf("cannot marshal %v into TraceValues: custom values are not supported", stringValue)
	}
	return json.Marshal(stringValue)

}

// The initialize parameters
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#xInitializeParams
type XInitializeParams struct {
	*WorkDoneProgressParams
	// The process Id of the parent process that started
	// the server.
	//
	// Is `null` if the process has not been started by another process.
	// If the parent process is not alive then the server should exit.
	ProcessId int `json:"processId"`
	// Information about the client
	//
	// @since 3.15.0
	ClientInfo *XInitializeParamsClientInfo `json:"clientInfo,omitempty"`
	// The locale the client is currently showing the user interface
	// in. This must not necessarily be the locale of the operating
	// system.
	//
	// Uses IETF language tags as the value's syntax
	// (See https://en.wikipedia.org/wiki/IETF_language_tag)
	//
	// @since 3.16.0
	Locale string `json:"locale,omitempty"`
	// The rootPath of the workspace. Is null
	// if no folder is open.
	//
	// Deprecated: in favour of rootUri.
	RootPath string `json:"rootPath,omitempty"`
	// The rootUri of the workspace. Is null if no
	// folder is open. If both `rootPath` and `rootUri` are set
	// `rootUri` wins.
	//
	// Deprecated: in favour of workspaceFolders.
	RootUri string `json:"rootUri"`
	// The capabilities provided by the client (editor or tool)
	Capabilities *ClientCapabilities `json:"capabilities"`
	// User provided initialization options.
	InitializationOptions LSPAny `json:"initializationOptions,omitempty"`
	// The initial trace setting. If omitted trace is disabled ('off').
	Trace TraceValues `json:"trace,omitempty"`
}

// A workspace folder inside a client.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceFolder
type WorkspaceFolder struct {
	// The associated URI for this workspace folder.
	Uri string `json:"uri"`
	// The name of the workspace folder. Used to refer to this
	// workspace folder in the user interface.
	Name string `json:"name"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceFoldersInitializeParams
type WorkspaceFoldersInitializeParams struct {
	// The workspace folders configured in the client when the server starts.
	//
	// This property is only available if the client supports workspace folders.
	// It can be `null` if the client supports workspace folders but none are
	// configured.
	//
	// @since 3.6.0
	WorkspaceFolders []*WorkspaceFolder `json:"workspaceFolders,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initializeParams
type InitializeParams struct {
	*XInitializeParams
	*WorkspaceFoldersInitializeParams
}

// Defines how the host (editor) should sync
// document changes to the language server.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentSyncKind
type TextDocumentSyncKind uint32

const (
	// Documents should not be synced at all.
	TextDocumentSyncKindNone TextDocumentSyncKind = 0
	// Documents are synced by always sending the full content
	// of the document.
	TextDocumentSyncKindFull TextDocumentSyncKind = 1
	// Documents are synced by sending the full content on open.
	// After that only incremental updates to the document are
	// send.
	TextDocumentSyncKindIncremental TextDocumentSyncKind = 2
)

var validTextDocumentSyncKindValues = map[uint32]bool{
	0: true,
	1: true,
	2: true,
}

func (t *TextDocumentSyncKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validTextDocumentSyncKindValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into TextDocumentSyncKind: custom values are not supported", uint32Value)
	}
	*t = TextDocumentSyncKind(uint32Value)

	return nil
}

func (t TextDocumentSyncKind) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(t)
	if !validTextDocumentSyncKindValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into TextDocumentSyncKind: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

// Save options.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#saveOptions
type SaveOptions struct {
	// The client is supposed to include the content on save.
	IncludeText bool `json:"includeText,omitempty"`
}

// BooleanOrSaveOptions contains either of the following types:
//   - [Boolean]
//   - [*SaveOptions]
type BooleanOrSaveOptions struct {
	Value BooleanOrSaveOptionsValue
}

// BooleanOrSaveOptionsValue is either of the following types:
//   - [Boolean]
//   - [*SaveOptions]
//
//gosumtype:decl BooleanOrSaveOptionsValue
type BooleanOrSaveOptionsValue interface {
	isBooleanOrSaveOptionsValue()
}

func (Boolean) isBooleanOrSaveOptionsValue()      {}
func (*SaveOptions) isBooleanOrSaveOptionsValue() {}

func (b *BooleanOrSaveOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var saveOptionsValue *SaveOptions
	if err := json.Unmarshal(data, &saveOptionsValue); err == nil {
		b.Value = saveOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrSaveOptions](),
	}
}

func (b BooleanOrSaveOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentSyncOptions
type TextDocumentSyncOptions struct {
	// Open and close notifications are sent to the server. If omitted open close notification should not
	// be sent.
	OpenClose bool `json:"openClose,omitempty"`
	// Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
	// and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
	Change TextDocumentSyncKind `json:"change,omitempty"`
	// If present will save notifications are sent to the server. If omitted the notification should not be
	// sent.
	WillSave bool `json:"willSave,omitempty"`
	// If present will save wait until requests are sent to the server. If omitted the request should not be
	// sent.
	WillSaveWaitUntil bool `json:"willSaveWaitUntil,omitempty"`
	// If present save notifications are sent to the server. If omitted the notification should not be
	// sent.
	Save *BooleanOrSaveOptions `json:"save,omitempty"`
}

// TextDocumentSyncOptionsOrTextDocumentSyncKind contains either of the following types:
//   - [*TextDocumentSyncOptions]
//   - [TextDocumentSyncKind]
type TextDocumentSyncOptionsOrTextDocumentSyncKind struct {
	Value TextDocumentSyncOptionsOrTextDocumentSyncKindValue
}

// TextDocumentSyncOptionsOrTextDocumentSyncKindValue is either of the following types:
//   - [*TextDocumentSyncOptions]
//   - [TextDocumentSyncKind]
//
//gosumtype:decl TextDocumentSyncOptionsOrTextDocumentSyncKindValue
type TextDocumentSyncOptionsOrTextDocumentSyncKindValue interface {
	isTextDocumentSyncOptionsOrTextDocumentSyncKindValue()
}

func (*TextDocumentSyncOptions) isTextDocumentSyncOptionsOrTextDocumentSyncKindValue() {}
func (TextDocumentSyncKind) isTextDocumentSyncOptionsOrTextDocumentSyncKindValue()     {}

func (t *TextDocumentSyncOptionsOrTextDocumentSyncKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var textDocumentSyncOptionsValue *TextDocumentSyncOptions
	if err := json.Unmarshal(data, &textDocumentSyncOptionsValue); err == nil {
		t.Value = textDocumentSyncOptionsValue
		return nil
	}
	var textDocumentSyncKindValue TextDocumentSyncKind
	if err := json.Unmarshal(data, &textDocumentSyncKindValue); err == nil {
		t.Value = textDocumentSyncKindValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*TextDocumentSyncOptionsOrTextDocumentSyncKind](),
	}
}

func (t TextDocumentSyncOptionsOrTextDocumentSyncKind) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.Value)
}

type NotebookDocumentFilterOr1 struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern.
	Pattern string `json:"pattern,omitempty"`
}

type NotebookDocumentFilterOr2 struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme"`
	// A glob pattern.
	Pattern string `json:"pattern,omitempty"`
}

type NotebookDocumentFilterOr3 struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern.
	Pattern string `json:"pattern"`
}

// NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3 contains either of the following types:
//   - [*NotebookDocumentFilterOr1]
//   - [*NotebookDocumentFilterOr2]
//   - [*NotebookDocumentFilterOr3]
type NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3 struct {
	Value NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value
}

// NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value is either of the following types:
//   - [*NotebookDocumentFilterOr1]
//   - [*NotebookDocumentFilterOr2]
//   - [*NotebookDocumentFilterOr3]
//
//gosumtype:decl NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value
type NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value interface {
	isNotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value()
}

func (*NotebookDocumentFilterOr1) isNotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value() {
}
func (*NotebookDocumentFilterOr2) isNotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value() {
}
func (*NotebookDocumentFilterOr3) isNotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3Value() {
}

func (n *NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var notebookDocumentFilterOr1Value *NotebookDocumentFilterOr1
	if err := json.Unmarshal(data, &notebookDocumentFilterOr1Value); err == nil {
		n.Value = notebookDocumentFilterOr1Value
		return nil
	}
	var notebookDocumentFilterOr2Value *NotebookDocumentFilterOr2
	if err := json.Unmarshal(data, &notebookDocumentFilterOr2Value); err == nil {
		n.Value = notebookDocumentFilterOr2Value
		return nil
	}
	var notebookDocumentFilterOr3Value *NotebookDocumentFilterOr3
	if err := json.Unmarshal(data, &notebookDocumentFilterOr3Value); err == nil {
		n.Value = notebookDocumentFilterOr3Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3](),
	}
}

func (n NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3) MarshalJSON() ([]byte, error) {
	return json.Marshal(n.Value)
}

// A notebook document filter denotes a notebook document by
// different properties. The properties will be match
// against the notebook's URI (same as with documents)
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocumentFilter
type NotebookDocumentFilter = *NotebookDocumentFilterOr1OrNotebookDocumentFilterOr2OrNotebookDocumentFilterOr3

// StringOrNotebookDocumentFilter contains either of the following types:
//   - [String]
//   - [NotebookDocumentFilter]
type StringOrNotebookDocumentFilter struct {
	Value StringOrNotebookDocumentFilterValue
}

// StringOrNotebookDocumentFilterValue is either of the following types:
//   - [String]
//   - [NotebookDocumentFilter]
//
//gosumtype:decl StringOrNotebookDocumentFilterValue
type StringOrNotebookDocumentFilterValue interface {
	isStringOrNotebookDocumentFilterValue()
}

func (String) isStringOrNotebookDocumentFilterValue()                 {}
func (NotebookDocumentFilter) isStringOrNotebookDocumentFilterValue() {}

func (s *StringOrNotebookDocumentFilter) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue String
	if err := json.Unmarshal(data, &stringValue); err == nil {
		s.Value = stringValue
		return nil
	}
	var notebookDocumentFilterValue NotebookDocumentFilter
	if err := json.Unmarshal(data, &notebookDocumentFilterValue); err == nil {
		s.Value = notebookDocumentFilterValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*StringOrNotebookDocumentFilter](),
	}
}

func (s StringOrNotebookDocumentFilter) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Value)
}

type NotebookDocumentSyncOptionsNotebookSelectorOr1Cells struct {
	Language string `json:"language"`
}

type NotebookDocumentSyncOptionsNotebookSelectorOr1 struct {
	// The notebook to be synced If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook *StringOrNotebookDocumentFilter `json:"notebook"`
	// The cells of the matching notebook to be synced.
	Cells []*NotebookDocumentSyncOptionsNotebookSelectorOr1Cells `json:"cells,omitempty"`
}

type NotebookDocumentSyncOptionsNotebookSelectorOr2Cells struct {
	Language string `json:"language"`
}

type NotebookDocumentSyncOptionsNotebookSelectorOr2 struct {
	// The notebook to be synced If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook *StringOrNotebookDocumentFilter `json:"notebook,omitempty"`
	// The cells of the matching notebook to be synced.
	Cells []*NotebookDocumentSyncOptionsNotebookSelectorOr2Cells `json:"cells"`
}

// NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2 contains either of the following types:
//   - [*NotebookDocumentSyncOptionsNotebookSelectorOr1]
//   - [*NotebookDocumentSyncOptionsNotebookSelectorOr2]
type NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2 struct {
	Value NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value
}

// NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value is either of the following types:
//   - [*NotebookDocumentSyncOptionsNotebookSelectorOr1]
//   - [*NotebookDocumentSyncOptionsNotebookSelectorOr2]
//
//gosumtype:decl NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value
type NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value interface {
	isNotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value()
}

func (*NotebookDocumentSyncOptionsNotebookSelectorOr1) isNotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value() {
}
func (*NotebookDocumentSyncOptionsNotebookSelectorOr2) isNotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2Value() {
}

func (n *NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var notebookDocumentSyncOptionsNotebookSelectorOr1Value *NotebookDocumentSyncOptionsNotebookSelectorOr1
	if err := json.Unmarshal(data, &notebookDocumentSyncOptionsNotebookSelectorOr1Value); err == nil {
		n.Value = notebookDocumentSyncOptionsNotebookSelectorOr1Value
		return nil
	}
	var notebookDocumentSyncOptionsNotebookSelectorOr2Value *NotebookDocumentSyncOptionsNotebookSelectorOr2
	if err := json.Unmarshal(data, &notebookDocumentSyncOptionsNotebookSelectorOr2Value); err == nil {
		n.Value = notebookDocumentSyncOptionsNotebookSelectorOr2Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2](),
	}
}

func (n NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2) MarshalJSON() ([]byte, error) {
	return json.Marshal(n.Value)
}

// Options specific to a notebook plus its cells
// to be synced to the server.
//
// If a selector provides a notebook document
// filter but no cell selector all cells of a
// matching notebook document will be synced.
//
// If a selector provides no notebook document
// filter but only a cell selector all notebook
// document that contain at least one matching
// cell will be synced.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocumentSyncOptions
type NotebookDocumentSyncOptions struct {
	// The notebooks to be synced
	NotebookSelector []*NotebookDocumentSyncOptionsNotebookSelectorOr1OrNotebookDocumentSyncOptionsNotebookSelectorOr2 `json:"notebookSelector"`
	// Whether save notification should be forwarded to
	// the server. Will only be honored if mode === `notebook`.
	Save bool `json:"save,omitempty"`
}

// Static registration options to be returned in the initialize
// request.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#staticRegistrationOptions
type StaticRegistrationOptions struct {
	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id string `json:"id,omitempty"`
}

// Registration options specific to a notebook.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocumentSyncRegistrationOptions
type NotebookDocumentSyncRegistrationOptions struct {
	*NotebookDocumentSyncOptions
	*StaticRegistrationOptions
}

// NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptions contains either of the following types:
//   - [*NotebookDocumentSyncOptions]
//   - [*NotebookDocumentSyncRegistrationOptions]
type NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptions struct {
	Value NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue
}

// NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue is either of the following types:
//   - [*NotebookDocumentSyncOptions]
//   - [*NotebookDocumentSyncRegistrationOptions]
//
//gosumtype:decl NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue
type NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue interface {
	isNotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue()
}

func (*NotebookDocumentSyncOptions) isNotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue() {
}
func (*NotebookDocumentSyncRegistrationOptions) isNotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptionsValue() {
}

func (n *NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var notebookDocumentSyncOptionsValue *NotebookDocumentSyncOptions
	if err := json.Unmarshal(data, &notebookDocumentSyncOptionsValue); err == nil {
		n.Value = notebookDocumentSyncOptionsValue
		return nil
	}
	var notebookDocumentSyncRegistrationOptionsValue *NotebookDocumentSyncRegistrationOptions
	if err := json.Unmarshal(data, &notebookDocumentSyncRegistrationOptionsValue); err == nil {
		n.Value = notebookDocumentSyncRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptions](),
	}
}

func (n NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(n.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workDoneProgressOptions
type WorkDoneProgressOptions struct {
	WorkDoneProgress bool `json:"workDoneProgress,omitempty"`
}

type CompletionOptionsCompletionItem struct {
	// The server has support for completion item label
	// details (see also `CompletionItemLabelDetails`) when
	// receiving a completion item in a resolve call.
	//
	// @since 3.17.0
	LabelDetailsSupport bool `json:"labelDetailsSupport,omitempty"`
}

// Completion options.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionOptions
type CompletionOptions struct {
	*WorkDoneProgressOptions
	// Most tools trigger completion request automatically without explicitly requesting
	// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
	// starts to type an identifier. For example if the user types `c` in a JavaScript file
	// code complete will automatically pop up present `console` besides others as a
	// completion item. Characters that make up identifiers don't need to be listed here.
	//
	// If code complete should automatically be trigger on characters not being valid inside
	// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
	TriggerCharacters []string `json:"triggerCharacters,omitempty"`
	// The list of all possible characters that commit a completion. This field can be used
	// if clients don't support individual commit characters per completion item. See
	// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
	//
	// If a server provides both `allCommitCharacters` and commit characters on an individual
	// completion item the ones on the completion item win.
	//
	// @since 3.2.0
	AllCommitCharacters []string `json:"allCommitCharacters,omitempty"`
	// The server provides support to resolve additional
	// information for a completion item.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
	// The server supports the following `CompletionItem` specific
	// capabilities.
	//
	// @since 3.17.0
	CompletionItem *CompletionOptionsCompletionItem `json:"completionItem,omitempty"`
}

// Hover options.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#hoverOptions
type HoverOptions struct {
	*WorkDoneProgressOptions
}

// BooleanOrHoverOptions contains either of the following types:
//   - [Boolean]
//   - [*HoverOptions]
type BooleanOrHoverOptions struct {
	Value BooleanOrHoverOptionsValue
}

// BooleanOrHoverOptionsValue is either of the following types:
//   - [Boolean]
//   - [*HoverOptions]
//
//gosumtype:decl BooleanOrHoverOptionsValue
type BooleanOrHoverOptionsValue interface {
	isBooleanOrHoverOptionsValue()
}

func (Boolean) isBooleanOrHoverOptionsValue()       {}
func (*HoverOptions) isBooleanOrHoverOptionsValue() {}

func (b *BooleanOrHoverOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var hoverOptionsValue *HoverOptions
	if err := json.Unmarshal(data, &hoverOptionsValue); err == nil {
		b.Value = hoverOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrHoverOptions](),
	}
}

func (b BooleanOrHoverOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Server Capabilities for a {@link SignatureHelpRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#signatureHelpOptions
type SignatureHelpOptions struct {
	*WorkDoneProgressOptions
	// List of characters that trigger signature help automatically.
	TriggerCharacters []string `json:"triggerCharacters,omitempty"`
	// List of characters that re-trigger signature help.
	//
	// These trigger characters are only active when signature help is already showing. All trigger characters
	// are also counted as re-trigger characters.
	//
	// @since 3.15.0
	RetriggerCharacters []string `json:"retriggerCharacters,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#declarationOptions
type DeclarationOptions struct {
	*WorkDoneProgressOptions
}

type TextDocumentFilterOr1 struct {
	// A language id, like `typescript`.
	Language string `json:"language"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples.
	Pattern string `json:"pattern,omitempty"`
}

type TextDocumentFilterOr2 struct {
	// A language id, like `typescript`.
	Language string `json:"language,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme"`
	// A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples.
	Pattern string `json:"pattern,omitempty"`
}

type TextDocumentFilterOr3 struct {
	// A language id, like `typescript`.
	Language string `json:"language,omitempty"`
	// A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples.
	Pattern string `json:"pattern"`
}

// TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3 contains either of the following types:
//   - [*TextDocumentFilterOr1]
//   - [*TextDocumentFilterOr2]
//   - [*TextDocumentFilterOr3]
type TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3 struct {
	Value TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value
}

// TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value is either of the following types:
//   - [*TextDocumentFilterOr1]
//   - [*TextDocumentFilterOr2]
//   - [*TextDocumentFilterOr3]
//
//gosumtype:decl TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value
type TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value interface {
	isTextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value()
}

func (*TextDocumentFilterOr1) isTextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value() {
}
func (*TextDocumentFilterOr2) isTextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value() {
}
func (*TextDocumentFilterOr3) isTextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3Value() {
}

func (t *TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var textDocumentFilterOr1Value *TextDocumentFilterOr1
	if err := json.Unmarshal(data, &textDocumentFilterOr1Value); err == nil {
		t.Value = textDocumentFilterOr1Value
		return nil
	}
	var textDocumentFilterOr2Value *TextDocumentFilterOr2
	if err := json.Unmarshal(data, &textDocumentFilterOr2Value); err == nil {
		t.Value = textDocumentFilterOr2Value
		return nil
	}
	var textDocumentFilterOr3Value *TextDocumentFilterOr3
	if err := json.Unmarshal(data, &textDocumentFilterOr3Value); err == nil {
		t.Value = textDocumentFilterOr3Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3](),
	}
}

func (t TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.Value)
}

// A document filter denotes a document by different properties like
// the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
// its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
//
// Glob patterns can have the following syntax:
// - `*` to match one or more characters in a path segment
// - `?` to match on one character in a path segment
// - `**` to match any number of path segments, including none
// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
//
// @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
// @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentFilter
type TextDocumentFilter = *TextDocumentFilterOr1OrTextDocumentFilterOr2OrTextDocumentFilterOr3

// A notebook cell text document filter denotes a cell text
// document by different properties.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookCellTextDocumentFilter
type NotebookCellTextDocumentFilter struct {
	// A filter that matches against the notebook
	// containing the notebook cell. If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook *StringOrNotebookDocumentFilter `json:"notebook"`
	// A language id like `python`.
	//
	// Will be matched against the language id of the
	// notebook cell document. '*' matches every language.
	Language string `json:"language,omitempty"`
}

// TextDocumentFilterOrNotebookCellTextDocumentFilter contains either of the following types:
//   - [TextDocumentFilter]
//   - [*NotebookCellTextDocumentFilter]
type TextDocumentFilterOrNotebookCellTextDocumentFilter struct {
	Value TextDocumentFilterOrNotebookCellTextDocumentFilterValue
}

// TextDocumentFilterOrNotebookCellTextDocumentFilterValue is either of the following types:
//   - [TextDocumentFilter]
//   - [*NotebookCellTextDocumentFilter]
//
//gosumtype:decl TextDocumentFilterOrNotebookCellTextDocumentFilterValue
type TextDocumentFilterOrNotebookCellTextDocumentFilterValue interface {
	isTextDocumentFilterOrNotebookCellTextDocumentFilterValue()
}

func (TextDocumentFilter) isTextDocumentFilterOrNotebookCellTextDocumentFilterValue()              {}
func (*NotebookCellTextDocumentFilter) isTextDocumentFilterOrNotebookCellTextDocumentFilterValue() {}

func (t *TextDocumentFilterOrNotebookCellTextDocumentFilter) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var textDocumentFilterValue TextDocumentFilter
	if err := json.Unmarshal(data, &textDocumentFilterValue); err == nil {
		t.Value = textDocumentFilterValue
		return nil
	}
	var notebookCellTextDocumentFilterValue *NotebookCellTextDocumentFilter
	if err := json.Unmarshal(data, &notebookCellTextDocumentFilterValue); err == nil {
		t.Value = notebookCellTextDocumentFilterValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*TextDocumentFilterOrNotebookCellTextDocumentFilter](),
	}
}

func (t TextDocumentFilterOrNotebookCellTextDocumentFilter) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.Value)
}

// A document filter describes a top level text document or
// a notebook cell document.
//
// @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentFilter
type DocumentFilter = *TextDocumentFilterOrNotebookCellTextDocumentFilter

// A document selector is the combination of one or many document filters.
//
// @sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;
//
// The use of a string as a document filter is deprecated @since 3.16.0.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentSelector
type DocumentSelector = []DocumentFilter

// General text document registration options.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentRegistrationOptions
type TextDocumentRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelector `json:"documentSelector"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#declarationRegistrationOptions
type DeclarationRegistrationOptions struct {
	*DeclarationOptions
	*TextDocumentRegistrationOptions
	*StaticRegistrationOptions
}

// BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*DeclarationOptions]
//   - [*DeclarationRegistrationOptions]
type BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions struct {
	Value BooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue
}

// BooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DeclarationOptions]
//   - [*DeclarationRegistrationOptions]
//
//gosumtype:decl BooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue
type BooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue interface {
	isBooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue()
}

func (Boolean) isBooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue()             {}
func (*DeclarationOptions) isBooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue() {}
func (*DeclarationRegistrationOptions) isBooleanOrDeclarationOptionsOrDeclarationRegistrationOptionsValue() {
}

func (b *BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var declarationOptionsValue *DeclarationOptions
	if err := json.Unmarshal(data, &declarationOptionsValue); err == nil {
		b.Value = declarationOptionsValue
		return nil
	}
	var declarationRegistrationOptionsValue *DeclarationRegistrationOptions
	if err := json.Unmarshal(data, &declarationRegistrationOptionsValue); err == nil {
		b.Value = declarationRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions](),
	}
}

func (b BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Server Capabilities for a {@link DefinitionRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#definitionOptions
type DefinitionOptions struct {
	*WorkDoneProgressOptions
}

// BooleanOrDefinitionOptions contains either of the following types:
//   - [Boolean]
//   - [*DefinitionOptions]
type BooleanOrDefinitionOptions struct {
	Value BooleanOrDefinitionOptionsValue
}

// BooleanOrDefinitionOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DefinitionOptions]
//
//gosumtype:decl BooleanOrDefinitionOptionsValue
type BooleanOrDefinitionOptionsValue interface {
	isBooleanOrDefinitionOptionsValue()
}

func (Boolean) isBooleanOrDefinitionOptionsValue()            {}
func (*DefinitionOptions) isBooleanOrDefinitionOptionsValue() {}

func (b *BooleanOrDefinitionOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var definitionOptionsValue *DefinitionOptions
	if err := json.Unmarshal(data, &definitionOptionsValue); err == nil {
		b.Value = definitionOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDefinitionOptions](),
	}
}

func (b BooleanOrDefinitionOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#typeDefinitionOptions
type TypeDefinitionOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#typeDefinitionRegistrationOptions
type TypeDefinitionRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*TypeDefinitionOptions
	*StaticRegistrationOptions
}

// BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*TypeDefinitionOptions]
//   - [*TypeDefinitionRegistrationOptions]
type BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions struct {
	Value BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue
}

// BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*TypeDefinitionOptions]
//   - [*TypeDefinitionRegistrationOptions]
//
//gosumtype:decl BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue
type BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue interface {
	isBooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue()
}

func (Boolean) isBooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue() {}
func (*TypeDefinitionOptions) isBooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue() {
}
func (*TypeDefinitionRegistrationOptions) isBooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptionsValue() {
}

func (b *BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var typeDefinitionOptionsValue *TypeDefinitionOptions
	if err := json.Unmarshal(data, &typeDefinitionOptionsValue); err == nil {
		b.Value = typeDefinitionOptionsValue
		return nil
	}
	var typeDefinitionRegistrationOptionsValue *TypeDefinitionRegistrationOptions
	if err := json.Unmarshal(data, &typeDefinitionRegistrationOptionsValue); err == nil {
		b.Value = typeDefinitionRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions](),
	}
}

func (b BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#implementationOptions
type ImplementationOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#implementationRegistrationOptions
type ImplementationRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*ImplementationOptions
	*StaticRegistrationOptions
}

// BooleanOrImplementationOptionsOrImplementationRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*ImplementationOptions]
//   - [*ImplementationRegistrationOptions]
type BooleanOrImplementationOptionsOrImplementationRegistrationOptions struct {
	Value BooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue
}

// BooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*ImplementationOptions]
//   - [*ImplementationRegistrationOptions]
//
//gosumtype:decl BooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue
type BooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue interface {
	isBooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue()
}

func (Boolean) isBooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue() {}
func (*ImplementationOptions) isBooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue() {
}
func (*ImplementationRegistrationOptions) isBooleanOrImplementationOptionsOrImplementationRegistrationOptionsValue() {
}

func (b *BooleanOrImplementationOptionsOrImplementationRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var implementationOptionsValue *ImplementationOptions
	if err := json.Unmarshal(data, &implementationOptionsValue); err == nil {
		b.Value = implementationOptionsValue
		return nil
	}
	var implementationRegistrationOptionsValue *ImplementationRegistrationOptions
	if err := json.Unmarshal(data, &implementationRegistrationOptionsValue); err == nil {
		b.Value = implementationRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrImplementationOptionsOrImplementationRegistrationOptions](),
	}
}

func (b BooleanOrImplementationOptionsOrImplementationRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Reference options.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#referenceOptions
type ReferenceOptions struct {
	*WorkDoneProgressOptions
}

// BooleanOrReferenceOptions contains either of the following types:
//   - [Boolean]
//   - [*ReferenceOptions]
type BooleanOrReferenceOptions struct {
	Value BooleanOrReferenceOptionsValue
}

// BooleanOrReferenceOptionsValue is either of the following types:
//   - [Boolean]
//   - [*ReferenceOptions]
//
//gosumtype:decl BooleanOrReferenceOptionsValue
type BooleanOrReferenceOptionsValue interface {
	isBooleanOrReferenceOptionsValue()
}

func (Boolean) isBooleanOrReferenceOptionsValue()           {}
func (*ReferenceOptions) isBooleanOrReferenceOptionsValue() {}

func (b *BooleanOrReferenceOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var referenceOptionsValue *ReferenceOptions
	if err := json.Unmarshal(data, &referenceOptionsValue); err == nil {
		b.Value = referenceOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrReferenceOptions](),
	}
}

func (b BooleanOrReferenceOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Provider options for a {@link DocumentHighlightRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentHighlightOptions
type DocumentHighlightOptions struct {
	*WorkDoneProgressOptions
}

// BooleanOrDocumentHighlightOptions contains either of the following types:
//   - [Boolean]
//   - [*DocumentHighlightOptions]
type BooleanOrDocumentHighlightOptions struct {
	Value BooleanOrDocumentHighlightOptionsValue
}

// BooleanOrDocumentHighlightOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DocumentHighlightOptions]
//
//gosumtype:decl BooleanOrDocumentHighlightOptionsValue
type BooleanOrDocumentHighlightOptionsValue interface {
	isBooleanOrDocumentHighlightOptionsValue()
}

func (Boolean) isBooleanOrDocumentHighlightOptionsValue()                   {}
func (*DocumentHighlightOptions) isBooleanOrDocumentHighlightOptionsValue() {}

func (b *BooleanOrDocumentHighlightOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var documentHighlightOptionsValue *DocumentHighlightOptions
	if err := json.Unmarshal(data, &documentHighlightOptionsValue); err == nil {
		b.Value = documentHighlightOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDocumentHighlightOptions](),
	}
}

func (b BooleanOrDocumentHighlightOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Provider options for a {@link DocumentSymbolRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentSymbolOptions
type DocumentSymbolOptions struct {
	*WorkDoneProgressOptions
	// A human-readable string that is shown when multiple outlines trees
	// are shown for the same document.
	//
	// @since 3.16.0
	Label string `json:"label,omitempty"`
}

// BooleanOrDocumentSymbolOptions contains either of the following types:
//   - [Boolean]
//   - [*DocumentSymbolOptions]
type BooleanOrDocumentSymbolOptions struct {
	Value BooleanOrDocumentSymbolOptionsValue
}

// BooleanOrDocumentSymbolOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DocumentSymbolOptions]
//
//gosumtype:decl BooleanOrDocumentSymbolOptionsValue
type BooleanOrDocumentSymbolOptionsValue interface {
	isBooleanOrDocumentSymbolOptionsValue()
}

func (Boolean) isBooleanOrDocumentSymbolOptionsValue()                {}
func (*DocumentSymbolOptions) isBooleanOrDocumentSymbolOptionsValue() {}

func (b *BooleanOrDocumentSymbolOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var documentSymbolOptionsValue *DocumentSymbolOptions
	if err := json.Unmarshal(data, &documentSymbolOptionsValue); err == nil {
		b.Value = documentSymbolOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDocumentSymbolOptions](),
	}
}

func (b BooleanOrDocumentSymbolOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Provider options for a {@link CodeActionRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionOptions
type CodeActionOptions struct {
	*WorkDoneProgressOptions
	// CodeActionKinds that this server may return.
	//
	// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
	// may list out every specific kind they provide.
	CodeActionKinds []CodeActionKind `json:"codeActionKinds,omitempty"`
	// The server provides support to resolve additional
	// information for a code action.
	//
	// @since 3.16.0
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

// BooleanOrCodeActionOptions contains either of the following types:
//   - [Boolean]
//   - [*CodeActionOptions]
type BooleanOrCodeActionOptions struct {
	Value BooleanOrCodeActionOptionsValue
}

// BooleanOrCodeActionOptionsValue is either of the following types:
//   - [Boolean]
//   - [*CodeActionOptions]
//
//gosumtype:decl BooleanOrCodeActionOptionsValue
type BooleanOrCodeActionOptionsValue interface {
	isBooleanOrCodeActionOptionsValue()
}

func (Boolean) isBooleanOrCodeActionOptionsValue()            {}
func (*CodeActionOptions) isBooleanOrCodeActionOptionsValue() {}

func (b *BooleanOrCodeActionOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var codeActionOptionsValue *CodeActionOptions
	if err := json.Unmarshal(data, &codeActionOptionsValue); err == nil {
		b.Value = codeActionOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrCodeActionOptions](),
	}
}

func (b BooleanOrCodeActionOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Code Lens provider options of a {@link CodeLensRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeLensOptions
type CodeLensOptions struct {
	*WorkDoneProgressOptions
	// Code lens has a resolve provider as well.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

// Provider options for a {@link DocumentLinkRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentLinkOptions
type DocumentLinkOptions struct {
	*WorkDoneProgressOptions
	// Document links have a resolve provider as well.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentColorOptions
type DocumentColorOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentColorRegistrationOptions
type DocumentColorRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*DocumentColorOptions
	*StaticRegistrationOptions
}

// BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*DocumentColorOptions]
//   - [*DocumentColorRegistrationOptions]
type BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions struct {
	Value BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue
}

// BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DocumentColorOptions]
//   - [*DocumentColorRegistrationOptions]
//
//gosumtype:decl BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue
type BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue interface {
	isBooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue()
}

func (Boolean) isBooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue() {}
func (*DocumentColorOptions) isBooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue() {
}
func (*DocumentColorRegistrationOptions) isBooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptionsValue() {
}

func (b *BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var documentColorOptionsValue *DocumentColorOptions
	if err := json.Unmarshal(data, &documentColorOptionsValue); err == nil {
		b.Value = documentColorOptionsValue
		return nil
	}
	var documentColorRegistrationOptionsValue *DocumentColorRegistrationOptions
	if err := json.Unmarshal(data, &documentColorRegistrationOptionsValue); err == nil {
		b.Value = documentColorRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions](),
	}
}

func (b BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Server capabilities for a {@link WorkspaceSymbolRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceSymbolOptions
type WorkspaceSymbolOptions struct {
	*WorkDoneProgressOptions
	// The server provides support to resolve additional
	// information for a workspace symbol.
	//
	// @since 3.17.0
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

// BooleanOrWorkspaceSymbolOptions contains either of the following types:
//   - [Boolean]
//   - [*WorkspaceSymbolOptions]
type BooleanOrWorkspaceSymbolOptions struct {
	Value BooleanOrWorkspaceSymbolOptionsValue
}

// BooleanOrWorkspaceSymbolOptionsValue is either of the following types:
//   - [Boolean]
//   - [*WorkspaceSymbolOptions]
//
//gosumtype:decl BooleanOrWorkspaceSymbolOptionsValue
type BooleanOrWorkspaceSymbolOptionsValue interface {
	isBooleanOrWorkspaceSymbolOptionsValue()
}

func (Boolean) isBooleanOrWorkspaceSymbolOptionsValue()                 {}
func (*WorkspaceSymbolOptions) isBooleanOrWorkspaceSymbolOptionsValue() {}

func (b *BooleanOrWorkspaceSymbolOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var workspaceSymbolOptionsValue *WorkspaceSymbolOptions
	if err := json.Unmarshal(data, &workspaceSymbolOptionsValue); err == nil {
		b.Value = workspaceSymbolOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrWorkspaceSymbolOptions](),
	}
}

func (b BooleanOrWorkspaceSymbolOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Provider options for a {@link DocumentFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentFormattingOptions
type DocumentFormattingOptions struct {
	*WorkDoneProgressOptions
}

// BooleanOrDocumentFormattingOptions contains either of the following types:
//   - [Boolean]
//   - [*DocumentFormattingOptions]
type BooleanOrDocumentFormattingOptions struct {
	Value BooleanOrDocumentFormattingOptionsValue
}

// BooleanOrDocumentFormattingOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DocumentFormattingOptions]
//
//gosumtype:decl BooleanOrDocumentFormattingOptionsValue
type BooleanOrDocumentFormattingOptionsValue interface {
	isBooleanOrDocumentFormattingOptionsValue()
}

func (Boolean) isBooleanOrDocumentFormattingOptionsValue()                    {}
func (*DocumentFormattingOptions) isBooleanOrDocumentFormattingOptionsValue() {}

func (b *BooleanOrDocumentFormattingOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var documentFormattingOptionsValue *DocumentFormattingOptions
	if err := json.Unmarshal(data, &documentFormattingOptionsValue); err == nil {
		b.Value = documentFormattingOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDocumentFormattingOptions](),
	}
}

func (b BooleanOrDocumentFormattingOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Provider options for a {@link DocumentRangeFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentRangeFormattingOptions
type DocumentRangeFormattingOptions struct {
	*WorkDoneProgressOptions
	// Whether the server supports formatting multiple ranges at once.
	//
	// @since 3.18.0
	// @proposed
	RangesSupport bool `json:"rangesSupport,omitempty"`
}

// BooleanOrDocumentRangeFormattingOptions contains either of the following types:
//   - [Boolean]
//   - [*DocumentRangeFormattingOptions]
type BooleanOrDocumentRangeFormattingOptions struct {
	Value BooleanOrDocumentRangeFormattingOptionsValue
}

// BooleanOrDocumentRangeFormattingOptionsValue is either of the following types:
//   - [Boolean]
//   - [*DocumentRangeFormattingOptions]
//
//gosumtype:decl BooleanOrDocumentRangeFormattingOptionsValue
type BooleanOrDocumentRangeFormattingOptionsValue interface {
	isBooleanOrDocumentRangeFormattingOptionsValue()
}

func (Boolean) isBooleanOrDocumentRangeFormattingOptionsValue()                         {}
func (*DocumentRangeFormattingOptions) isBooleanOrDocumentRangeFormattingOptionsValue() {}

func (b *BooleanOrDocumentRangeFormattingOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var documentRangeFormattingOptionsValue *DocumentRangeFormattingOptions
	if err := json.Unmarshal(data, &documentRangeFormattingOptionsValue); err == nil {
		b.Value = documentRangeFormattingOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrDocumentRangeFormattingOptions](),
	}
}

func (b BooleanOrDocumentRangeFormattingOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Provider options for a {@link DocumentOnTypeFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentOnTypeFormattingOptions
type DocumentOnTypeFormattingOptions struct {
	// A character on which formatting should be triggered, like `{`.
	FirstTriggerCharacter string `json:"firstTriggerCharacter"`
	// More trigger characters.
	MoreTriggerCharacter []string `json:"moreTriggerCharacter,omitempty"`
}

// Provider options for a {@link RenameRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#renameOptions
type RenameOptions struct {
	*WorkDoneProgressOptions
	// Renames should be checked and tested before being executed.
	//
	// @since version 3.12.0
	PrepareProvider bool `json:"prepareProvider,omitempty"`
}

// BooleanOrRenameOptions contains either of the following types:
//   - [Boolean]
//   - [*RenameOptions]
type BooleanOrRenameOptions struct {
	Value BooleanOrRenameOptionsValue
}

// BooleanOrRenameOptionsValue is either of the following types:
//   - [Boolean]
//   - [*RenameOptions]
//
//gosumtype:decl BooleanOrRenameOptionsValue
type BooleanOrRenameOptionsValue interface {
	isBooleanOrRenameOptionsValue()
}

func (Boolean) isBooleanOrRenameOptionsValue()        {}
func (*RenameOptions) isBooleanOrRenameOptionsValue() {}

func (b *BooleanOrRenameOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var renameOptionsValue *RenameOptions
	if err := json.Unmarshal(data, &renameOptionsValue); err == nil {
		b.Value = renameOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrRenameOptions](),
	}
}

func (b BooleanOrRenameOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#foldingRangeOptions
type FoldingRangeOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#foldingRangeRegistrationOptions
type FoldingRangeRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*FoldingRangeOptions
	*StaticRegistrationOptions
}

// BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*FoldingRangeOptions]
//   - [*FoldingRangeRegistrationOptions]
type BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions struct {
	Value BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue
}

// BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*FoldingRangeOptions]
//   - [*FoldingRangeRegistrationOptions]
//
//gosumtype:decl BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue
type BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue interface {
	isBooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue()
}

func (Boolean) isBooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue()              {}
func (*FoldingRangeOptions) isBooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue() {}
func (*FoldingRangeRegistrationOptions) isBooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptionsValue() {
}

func (b *BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var foldingRangeOptionsValue *FoldingRangeOptions
	if err := json.Unmarshal(data, &foldingRangeOptionsValue); err == nil {
		b.Value = foldingRangeOptionsValue
		return nil
	}
	var foldingRangeRegistrationOptionsValue *FoldingRangeRegistrationOptions
	if err := json.Unmarshal(data, &foldingRangeRegistrationOptionsValue); err == nil {
		b.Value = foldingRangeRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions](),
	}
}

func (b BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#selectionRangeOptions
type SelectionRangeOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#selectionRangeRegistrationOptions
type SelectionRangeRegistrationOptions struct {
	*SelectionRangeOptions
	*TextDocumentRegistrationOptions
	*StaticRegistrationOptions
}

// BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*SelectionRangeOptions]
//   - [*SelectionRangeRegistrationOptions]
type BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions struct {
	Value BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue
}

// BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*SelectionRangeOptions]
//   - [*SelectionRangeRegistrationOptions]
//
//gosumtype:decl BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue
type BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue interface {
	isBooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue()
}

func (Boolean) isBooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue() {}
func (*SelectionRangeOptions) isBooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue() {
}
func (*SelectionRangeRegistrationOptions) isBooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptionsValue() {
}

func (b *BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var selectionRangeOptionsValue *SelectionRangeOptions
	if err := json.Unmarshal(data, &selectionRangeOptionsValue); err == nil {
		b.Value = selectionRangeOptionsValue
		return nil
	}
	var selectionRangeRegistrationOptionsValue *SelectionRangeRegistrationOptions
	if err := json.Unmarshal(data, &selectionRangeRegistrationOptionsValue); err == nil {
		b.Value = selectionRangeRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions](),
	}
}

func (b BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// The server capabilities of a {@link ExecuteCommandRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#executeCommandOptions
type ExecuteCommandOptions struct {
	*WorkDoneProgressOptions
	// The commands to be executed on the server
	Commands []string `json:"commands"`
}

// Call hierarchy options used during static registration.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#callHierarchyOptions
type CallHierarchyOptions struct {
	*WorkDoneProgressOptions
}

// Call hierarchy options used during static or dynamic registration.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#callHierarchyRegistrationOptions
type CallHierarchyRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*CallHierarchyOptions
	*StaticRegistrationOptions
}

// BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*CallHierarchyOptions]
//   - [*CallHierarchyRegistrationOptions]
type BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions struct {
	Value BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue
}

// BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*CallHierarchyOptions]
//   - [*CallHierarchyRegistrationOptions]
//
//gosumtype:decl BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue
type BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue interface {
	isBooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue()
}

func (Boolean) isBooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue() {}
func (*CallHierarchyOptions) isBooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue() {
}
func (*CallHierarchyRegistrationOptions) isBooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptionsValue() {
}

func (b *BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var callHierarchyOptionsValue *CallHierarchyOptions
	if err := json.Unmarshal(data, &callHierarchyOptionsValue); err == nil {
		b.Value = callHierarchyOptionsValue
		return nil
	}
	var callHierarchyRegistrationOptionsValue *CallHierarchyRegistrationOptions
	if err := json.Unmarshal(data, &callHierarchyRegistrationOptionsValue); err == nil {
		b.Value = callHierarchyRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions](),
	}
}

func (b BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#linkedEditingRangeOptions
type LinkedEditingRangeOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#linkedEditingRangeRegistrationOptions
type LinkedEditingRangeRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*LinkedEditingRangeOptions
	*StaticRegistrationOptions
}

// BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*LinkedEditingRangeOptions]
//   - [*LinkedEditingRangeRegistrationOptions]
type BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions struct {
	Value BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue
}

// BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*LinkedEditingRangeOptions]
//   - [*LinkedEditingRangeRegistrationOptions]
//
//gosumtype:decl BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue
type BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue interface {
	isBooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue()
}

func (Boolean) isBooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue() {}
func (*LinkedEditingRangeOptions) isBooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue() {
}
func (*LinkedEditingRangeRegistrationOptions) isBooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptionsValue() {
}

func (b *BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var linkedEditingRangeOptionsValue *LinkedEditingRangeOptions
	if err := json.Unmarshal(data, &linkedEditingRangeOptionsValue); err == nil {
		b.Value = linkedEditingRangeOptionsValue
		return nil
	}
	var linkedEditingRangeRegistrationOptionsValue *LinkedEditingRangeRegistrationOptions
	if err := json.Unmarshal(data, &linkedEditingRangeRegistrationOptionsValue); err == nil {
		b.Value = linkedEditingRangeRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions](),
	}
}

func (b BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#semanticTokensLegend
type SemanticTokensLegend struct {
	// The token types a server uses.
	TokenTypes []string `json:"tokenTypes"`
	// The token modifiers a server uses.
	TokenModifiers []string `json:"tokenModifiers"`
}

type SemanticTokensOptionsRangeOr2 struct {
}

// BooleanOrSemanticTokensOptionsRangeOr2 contains either of the following types:
//   - [Boolean]
//   - [*SemanticTokensOptionsRangeOr2]
type BooleanOrSemanticTokensOptionsRangeOr2 struct {
	Value BooleanOrSemanticTokensOptionsRangeOr2Value
}

// BooleanOrSemanticTokensOptionsRangeOr2Value is either of the following types:
//   - [Boolean]
//   - [*SemanticTokensOptionsRangeOr2]
//
//gosumtype:decl BooleanOrSemanticTokensOptionsRangeOr2Value
type BooleanOrSemanticTokensOptionsRangeOr2Value interface {
	isBooleanOrSemanticTokensOptionsRangeOr2Value()
}

func (Boolean) isBooleanOrSemanticTokensOptionsRangeOr2Value()                        {}
func (*SemanticTokensOptionsRangeOr2) isBooleanOrSemanticTokensOptionsRangeOr2Value() {}

func (b *BooleanOrSemanticTokensOptionsRangeOr2) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var semanticTokensOptionsRangeOr2Value *SemanticTokensOptionsRangeOr2
	if err := json.Unmarshal(data, &semanticTokensOptionsRangeOr2Value); err == nil {
		b.Value = semanticTokensOptionsRangeOr2Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrSemanticTokensOptionsRangeOr2](),
	}
}

func (b BooleanOrSemanticTokensOptionsRangeOr2) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

type SemanticTokensOptionsFullOr2 struct {
	// The server supports deltas for full documents.
	Delta bool `json:"delta,omitempty"`
}

// BooleanOrSemanticTokensOptionsFullOr2 contains either of the following types:
//   - [Boolean]
//   - [*SemanticTokensOptionsFullOr2]
type BooleanOrSemanticTokensOptionsFullOr2 struct {
	Value BooleanOrSemanticTokensOptionsFullOr2Value
}

// BooleanOrSemanticTokensOptionsFullOr2Value is either of the following types:
//   - [Boolean]
//   - [*SemanticTokensOptionsFullOr2]
//
//gosumtype:decl BooleanOrSemanticTokensOptionsFullOr2Value
type BooleanOrSemanticTokensOptionsFullOr2Value interface {
	isBooleanOrSemanticTokensOptionsFullOr2Value()
}

func (Boolean) isBooleanOrSemanticTokensOptionsFullOr2Value()                       {}
func (*SemanticTokensOptionsFullOr2) isBooleanOrSemanticTokensOptionsFullOr2Value() {}

func (b *BooleanOrSemanticTokensOptionsFullOr2) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var semanticTokensOptionsFullOr2Value *SemanticTokensOptionsFullOr2
	if err := json.Unmarshal(data, &semanticTokensOptionsFullOr2Value); err == nil {
		b.Value = semanticTokensOptionsFullOr2Value
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrSemanticTokensOptionsFullOr2](),
	}
}

func (b BooleanOrSemanticTokensOptionsFullOr2) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#semanticTokensOptions
type SemanticTokensOptions struct {
	*WorkDoneProgressOptions
	// The legend used by the server
	Legend *SemanticTokensLegend `json:"legend"`
	// Server supports providing semantic tokens for a specific range
	// of a document.
	Range *BooleanOrSemanticTokensOptionsRangeOr2 `json:"range,omitempty"`
	// Server supports providing semantic tokens for a full document.
	Full *BooleanOrSemanticTokensOptionsFullOr2 `json:"full,omitempty"`
}

// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#semanticTokensRegistrationOptions
type SemanticTokensRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*SemanticTokensOptions
	*StaticRegistrationOptions
}

// SemanticTokensOptionsOrSemanticTokensRegistrationOptions contains either of the following types:
//   - [*SemanticTokensOptions]
//   - [*SemanticTokensRegistrationOptions]
type SemanticTokensOptionsOrSemanticTokensRegistrationOptions struct {
	Value SemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue
}

// SemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue is either of the following types:
//   - [*SemanticTokensOptions]
//   - [*SemanticTokensRegistrationOptions]
//
//gosumtype:decl SemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue
type SemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue interface {
	isSemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue()
}

func (*SemanticTokensOptions) isSemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue() {}
func (*SemanticTokensRegistrationOptions) isSemanticTokensOptionsOrSemanticTokensRegistrationOptionsValue() {
}

func (s *SemanticTokensOptionsOrSemanticTokensRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var semanticTokensOptionsValue *SemanticTokensOptions
	if err := json.Unmarshal(data, &semanticTokensOptionsValue); err == nil {
		s.Value = semanticTokensOptionsValue
		return nil
	}
	var semanticTokensRegistrationOptionsValue *SemanticTokensRegistrationOptions
	if err := json.Unmarshal(data, &semanticTokensRegistrationOptionsValue); err == nil {
		s.Value = semanticTokensRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*SemanticTokensOptionsOrSemanticTokensRegistrationOptions](),
	}
}

func (s SemanticTokensOptionsOrSemanticTokensRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#monikerOptions
type MonikerOptions struct {
	*WorkDoneProgressOptions
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#monikerRegistrationOptions
type MonikerRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*MonikerOptions
}

// BooleanOrMonikerOptionsOrMonikerRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*MonikerOptions]
//   - [*MonikerRegistrationOptions]
type BooleanOrMonikerOptionsOrMonikerRegistrationOptions struct {
	Value BooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue
}

// BooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*MonikerOptions]
//   - [*MonikerRegistrationOptions]
//
//gosumtype:decl BooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue
type BooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue interface {
	isBooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue()
}

func (Boolean) isBooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue()                     {}
func (*MonikerOptions) isBooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue()             {}
func (*MonikerRegistrationOptions) isBooleanOrMonikerOptionsOrMonikerRegistrationOptionsValue() {}

func (b *BooleanOrMonikerOptionsOrMonikerRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var monikerOptionsValue *MonikerOptions
	if err := json.Unmarshal(data, &monikerOptionsValue); err == nil {
		b.Value = monikerOptionsValue
		return nil
	}
	var monikerRegistrationOptionsValue *MonikerRegistrationOptions
	if err := json.Unmarshal(data, &monikerRegistrationOptionsValue); err == nil {
		b.Value = monikerRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrMonikerOptionsOrMonikerRegistrationOptions](),
	}
}

func (b BooleanOrMonikerOptionsOrMonikerRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Type hierarchy options used during static registration.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#typeHierarchyOptions
type TypeHierarchyOptions struct {
	*WorkDoneProgressOptions
}

// Type hierarchy options used during static or dynamic registration.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#typeHierarchyRegistrationOptions
type TypeHierarchyRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*TypeHierarchyOptions
	*StaticRegistrationOptions
}

// BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*TypeHierarchyOptions]
//   - [*TypeHierarchyRegistrationOptions]
type BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions struct {
	Value BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue
}

// BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*TypeHierarchyOptions]
//   - [*TypeHierarchyRegistrationOptions]
//
//gosumtype:decl BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue
type BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue interface {
	isBooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue()
}

func (Boolean) isBooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue() {}
func (*TypeHierarchyOptions) isBooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue() {
}
func (*TypeHierarchyRegistrationOptions) isBooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptionsValue() {
}

func (b *BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var typeHierarchyOptionsValue *TypeHierarchyOptions
	if err := json.Unmarshal(data, &typeHierarchyOptionsValue); err == nil {
		b.Value = typeHierarchyOptionsValue
		return nil
	}
	var typeHierarchyRegistrationOptionsValue *TypeHierarchyRegistrationOptions
	if err := json.Unmarshal(data, &typeHierarchyRegistrationOptionsValue); err == nil {
		b.Value = typeHierarchyRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions](),
	}
}

func (b BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Inline value options used during static registration.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlineValueOptions
type InlineValueOptions struct {
	*WorkDoneProgressOptions
}

// Inline value options used during static or dynamic registration.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlineValueRegistrationOptions
type InlineValueRegistrationOptions struct {
	*InlineValueOptions
	*TextDocumentRegistrationOptions
	*StaticRegistrationOptions
}

// BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*InlineValueOptions]
//   - [*InlineValueRegistrationOptions]
type BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions struct {
	Value BooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue
}

// BooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*InlineValueOptions]
//   - [*InlineValueRegistrationOptions]
//
//gosumtype:decl BooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue
type BooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue interface {
	isBooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue()
}

func (Boolean) isBooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue()             {}
func (*InlineValueOptions) isBooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue() {}
func (*InlineValueRegistrationOptions) isBooleanOrInlineValueOptionsOrInlineValueRegistrationOptionsValue() {
}

func (b *BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var inlineValueOptionsValue *InlineValueOptions
	if err := json.Unmarshal(data, &inlineValueOptionsValue); err == nil {
		b.Value = inlineValueOptionsValue
		return nil
	}
	var inlineValueRegistrationOptionsValue *InlineValueRegistrationOptions
	if err := json.Unmarshal(data, &inlineValueRegistrationOptionsValue); err == nil {
		b.Value = inlineValueRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions](),
	}
}

func (b BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Inlay hint options used during static registration.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHintOptions
type InlayHintOptions struct {
	*WorkDoneProgressOptions
	// The server provides support to resolve additional
	// information for an inlay hint item.
	ResolveProvider bool `json:"resolveProvider,omitempty"`
}

// Inlay hint options used during static or dynamic registration.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHintRegistrationOptions
type InlayHintRegistrationOptions struct {
	*InlayHintOptions
	*TextDocumentRegistrationOptions
	*StaticRegistrationOptions
}

// BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions contains either of the following types:
//   - [Boolean]
//   - [*InlayHintOptions]
//   - [*InlayHintRegistrationOptions]
type BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions struct {
	Value BooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue
}

// BooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue is either of the following types:
//   - [Boolean]
//   - [*InlayHintOptions]
//   - [*InlayHintRegistrationOptions]
//
//gosumtype:decl BooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue
type BooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue interface {
	isBooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue()
}

func (Boolean) isBooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue()           {}
func (*InlayHintOptions) isBooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue() {}
func (*InlayHintRegistrationOptions) isBooleanOrInlayHintOptionsOrInlayHintRegistrationOptionsValue() {
}

func (b *BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var inlayHintOptionsValue *InlayHintOptions
	if err := json.Unmarshal(data, &inlayHintOptionsValue); err == nil {
		b.Value = inlayHintOptionsValue
		return nil
	}
	var inlayHintRegistrationOptionsValue *InlayHintRegistrationOptions
	if err := json.Unmarshal(data, &inlayHintRegistrationOptionsValue); err == nil {
		b.Value = inlayHintRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions](),
	}
}

func (b BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// Diagnostic options.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticOptions
type DiagnosticOptions struct {
	*WorkDoneProgressOptions
	// An optional identifier under which the diagnostics are
	// managed by the client.
	Identifier string `json:"identifier,omitempty"`
	// Whether the language has inter file dependencies meaning that
	// editing code in one file can result in a different diagnostic
	// set in another file. Inter file dependencies are common for
	// most programming languages and typically uncommon for linters.
	InterFileDependencies bool `json:"interFileDependencies"`
	// The server provides support for workspace diagnostics as well.
	WorkspaceDiagnostics bool `json:"workspaceDiagnostics"`
}

// Diagnostic registration options.
//
// @since 3.17.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticRegistrationOptions
type DiagnosticRegistrationOptions struct {
	*TextDocumentRegistrationOptions
	*DiagnosticOptions
	*StaticRegistrationOptions
}

// DiagnosticOptionsOrDiagnosticRegistrationOptions contains either of the following types:
//   - [*DiagnosticOptions]
//   - [*DiagnosticRegistrationOptions]
type DiagnosticOptionsOrDiagnosticRegistrationOptions struct {
	Value DiagnosticOptionsOrDiagnosticRegistrationOptionsValue
}

// DiagnosticOptionsOrDiagnosticRegistrationOptionsValue is either of the following types:
//   - [*DiagnosticOptions]
//   - [*DiagnosticRegistrationOptions]
//
//gosumtype:decl DiagnosticOptionsOrDiagnosticRegistrationOptionsValue
type DiagnosticOptionsOrDiagnosticRegistrationOptionsValue interface {
	isDiagnosticOptionsOrDiagnosticRegistrationOptionsValue()
}

func (*DiagnosticOptions) isDiagnosticOptionsOrDiagnosticRegistrationOptionsValue()             {}
func (*DiagnosticRegistrationOptions) isDiagnosticOptionsOrDiagnosticRegistrationOptionsValue() {}

func (d *DiagnosticOptionsOrDiagnosticRegistrationOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var diagnosticOptionsValue *DiagnosticOptions
	if err := json.Unmarshal(data, &diagnosticOptionsValue); err == nil {
		d.Value = diagnosticOptionsValue
		return nil
	}
	var diagnosticRegistrationOptionsValue *DiagnosticRegistrationOptions
	if err := json.Unmarshal(data, &diagnosticRegistrationOptionsValue); err == nil {
		d.Value = diagnosticRegistrationOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*DiagnosticOptionsOrDiagnosticRegistrationOptions](),
	}
}

func (d DiagnosticOptionsOrDiagnosticRegistrationOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Value)
}

// Inline completion options used during static registration.
//
// @since 3.18.0
// @proposed
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlineCompletionOptions
type InlineCompletionOptions struct {
	*WorkDoneProgressOptions
}

// BooleanOrInlineCompletionOptions contains either of the following types:
//   - [Boolean]
//   - [*InlineCompletionOptions]
type BooleanOrInlineCompletionOptions struct {
	Value BooleanOrInlineCompletionOptionsValue
}

// BooleanOrInlineCompletionOptionsValue is either of the following types:
//   - [Boolean]
//   - [*InlineCompletionOptions]
//
//gosumtype:decl BooleanOrInlineCompletionOptionsValue
type BooleanOrInlineCompletionOptionsValue interface {
	isBooleanOrInlineCompletionOptionsValue()
}

func (Boolean) isBooleanOrInlineCompletionOptionsValue()                  {}
func (*InlineCompletionOptions) isBooleanOrInlineCompletionOptionsValue() {}

func (b *BooleanOrInlineCompletionOptions) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		b.Value = booleanValue
		return nil
	}
	var inlineCompletionOptionsValue *InlineCompletionOptions
	if err := json.Unmarshal(data, &inlineCompletionOptionsValue); err == nil {
		b.Value = inlineCompletionOptionsValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*BooleanOrInlineCompletionOptions](),
	}
}

func (b BooleanOrInlineCompletionOptions) MarshalJSON() ([]byte, error) {
	return json.Marshal(b.Value)
}

// StringOrBoolean contains either of the following types:
//   - [String]
//   - [Boolean]
type StringOrBoolean struct {
	Value StringOrBooleanValue
}

// StringOrBooleanValue is either of the following types:
//   - [String]
//   - [Boolean]
//
//gosumtype:decl StringOrBooleanValue
type StringOrBooleanValue interface {
	isStringOrBooleanValue()
}

func (String) isStringOrBooleanValue()  {}
func (Boolean) isStringOrBooleanValue() {}

func (s *StringOrBoolean) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue String
	if err := json.Unmarshal(data, &stringValue); err == nil {
		s.Value = stringValue
		return nil
	}
	var booleanValue Boolean
	if err := json.Unmarshal(data, &booleanValue); err == nil {
		s.Value = booleanValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*StringOrBoolean](),
	}
}

func (s StringOrBoolean) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Value)
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceFoldersServerCapabilities
type WorkspaceFoldersServerCapabilities struct {
	// The server has support for workspace folders
	Supported bool `json:"supported,omitempty"`
	// Whether the server wants to receive workspace folder
	// change notifications.
	//
	// If a string is provided the string is treated as an ID
	// under which the notification is registered on the client
	// side. The ID can be used to unregister for these events
	// using the `client/unregisterCapability` request.
	ChangeNotifications *StringOrBoolean `json:"changeNotifications,omitempty"`
}

// A pattern kind describing if a glob pattern matches a file a folder or
// both.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationPatternKind
type FileOperationPatternKind string

const (
	// The pattern matches a file only.
	FileOperationPatternKindfile FileOperationPatternKind = "file"
	// The pattern matches a folder only.
	FileOperationPatternKindfolder FileOperationPatternKind = "folder"
)

var validFileOperationPatternKindValues = map[string]bool{
	"file":   true,
	"folder": true,
}

func (f *FileOperationPatternKind) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var stringValue string
	if err := json.Unmarshal(data, &stringValue); err != nil {
		return err
	}
	if !validFileOperationPatternKindValues[stringValue] {
		return fmt.Errorf("cannot unmarshal %v into FileOperationPatternKind: custom values are not supported", stringValue)
	}
	*f = FileOperationPatternKind(stringValue)

	return nil
}

func (f FileOperationPatternKind) MarshalJSON() ([]byte, error) {
	var stringValue = string(f)
	if !validFileOperationPatternKindValues[stringValue] {
		return nil, fmt.Errorf("cannot marshal %v into FileOperationPatternKind: custom values are not supported", stringValue)
	}
	return json.Marshal(stringValue)

}

// Matching options for the file operation pattern.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationPatternOptions
type FileOperationPatternOptions struct {
	// The pattern should be matched ignoring casing.
	IgnoreCase bool `json:"ignoreCase,omitempty"`
}

// A pattern to describe in which file operation requests or notifications
// the server is interested in receiving.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationPattern
type FileOperationPattern struct {
	// The glob pattern to match. Glob patterns can have the following syntax:
	// - `*` to match one or more characters in a path segment
	// - `?` to match on one character in a path segment
	// - `**` to match any number of path segments, including none
	// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
	// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
	// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
	Glob string `json:"glob"`
	// Whether to match files or folders with this pattern.
	//
	// Matches both if undefined.
	Matches FileOperationPatternKind `json:"matches,omitempty"`
	// Additional options used during matching.
	Options *FileOperationPatternOptions `json:"options,omitempty"`
}

// A filter to describe in which file operation requests or notifications
// the server is interested in receiving.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationFilter
type FileOperationFilter struct {
	// A Uri scheme like `file` or `untitled`.
	Scheme string `json:"scheme,omitempty"`
	// The actual file operation pattern.
	Pattern *FileOperationPattern `json:"pattern"`
}

// The options to register for file operations.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationRegistrationOptions
type FileOperationRegistrationOptions struct {
	// The actual filters.
	Filters []*FileOperationFilter `json:"filters"`
}

// Options for notifications/requests for user operations on files.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#fileOperationOptions
type FileOperationOptions struct {
	// The server is interested in receiving didCreateFiles notifications.
	DidCreate *FileOperationRegistrationOptions `json:"didCreate,omitempty"`
	// The server is interested in receiving willCreateFiles requests.
	WillCreate *FileOperationRegistrationOptions `json:"willCreate,omitempty"`
	// The server is interested in receiving didRenameFiles notifications.
	DidRename *FileOperationRegistrationOptions `json:"didRename,omitempty"`
	// The server is interested in receiving willRenameFiles requests.
	WillRename *FileOperationRegistrationOptions `json:"willRename,omitempty"`
	// The server is interested in receiving didDeleteFiles file notifications.
	DidDelete *FileOperationRegistrationOptions `json:"didDelete,omitempty"`
	// The server is interested in receiving willDeleteFiles file requests.
	WillDelete *FileOperationRegistrationOptions `json:"willDelete,omitempty"`
}

type ServerCapabilitiesWorkspace struct {
	// The server supports workspace folder.
	//
	// @since 3.6.0
	WorkspaceFolders *WorkspaceFoldersServerCapabilities `json:"workspaceFolders,omitempty"`
	// The server is interested in notifications/requests for operations on files.
	//
	// @since 3.16.0
	FileOperations *FileOperationOptions `json:"fileOperations,omitempty"`
}

// Defines the capabilities provided by a language
// server.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#serverCapabilities
type ServerCapabilities struct {
	// The position encoding the server picked from the encodings offered
	// by the client via the client capability `general.positionEncodings`.
	//
	// If the client didn't provide any position encodings the only valid
	// value that a server can return is 'utf-16'.
	//
	// If omitted it defaults to 'utf-16'.
	//
	// @since 3.17.0
	PositionEncoding PositionEncodingKind `json:"positionEncoding,omitempty"`
	// Defines how text documents are synced. Is either a detailed structure
	// defining each notification or for backwards compatibility the
	// TextDocumentSyncKind number.
	TextDocumentSync *TextDocumentSyncOptionsOrTextDocumentSyncKind `json:"textDocumentSync,omitempty"`
	// Defines how notebook documents are synced.
	//
	// @since 3.17.0
	NotebookDocumentSync *NotebookDocumentSyncOptionsOrNotebookDocumentSyncRegistrationOptions `json:"notebookDocumentSync,omitempty"`
	// The server provides completion support.
	CompletionProvider *CompletionOptions `json:"completionProvider,omitempty"`
	// The server provides hover support.
	HoverProvider *BooleanOrHoverOptions `json:"hoverProvider,omitempty"`
	// The server provides signature help support.
	SignatureHelpProvider *SignatureHelpOptions `json:"signatureHelpProvider,omitempty"`
	// The server provides Goto Declaration support.
	DeclarationProvider *BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions `json:"declarationProvider,omitempty"`
	// The server provides goto definition support.
	DefinitionProvider *BooleanOrDefinitionOptions `json:"definitionProvider,omitempty"`
	// The server provides Goto Type Definition support.
	TypeDefinitionProvider *BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions `json:"typeDefinitionProvider,omitempty"`
	// The server provides Goto Implementation support.
	ImplementationProvider *BooleanOrImplementationOptionsOrImplementationRegistrationOptions `json:"implementationProvider,omitempty"`
	// The server provides find references support.
	ReferencesProvider *BooleanOrReferenceOptions `json:"referencesProvider,omitempty"`
	// The server provides document highlight support.
	DocumentHighlightProvider *BooleanOrDocumentHighlightOptions `json:"documentHighlightProvider,omitempty"`
	// The server provides document symbol support.
	DocumentSymbolProvider *BooleanOrDocumentSymbolOptions `json:"documentSymbolProvider,omitempty"`
	// The server provides code actions. CodeActionOptions may only be
	// specified if the client states that it supports
	// `codeActionLiteralSupport` in its initial `initialize` request.
	CodeActionProvider *BooleanOrCodeActionOptions `json:"codeActionProvider,omitempty"`
	// The server provides code lens.
	CodeLensProvider *CodeLensOptions `json:"codeLensProvider,omitempty"`
	// The server provides document link support.
	DocumentLinkProvider *DocumentLinkOptions `json:"documentLinkProvider,omitempty"`
	// The server provides color provider support.
	ColorProvider *BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions `json:"colorProvider,omitempty"`
	// The server provides workspace symbol support.
	WorkspaceSymbolProvider *BooleanOrWorkspaceSymbolOptions `json:"workspaceSymbolProvider,omitempty"`
	// The server provides document formatting.
	DocumentFormattingProvider *BooleanOrDocumentFormattingOptions `json:"documentFormattingProvider,omitempty"`
	// The server provides document range formatting.
	DocumentRangeFormattingProvider *BooleanOrDocumentRangeFormattingOptions `json:"documentRangeFormattingProvider,omitempty"`
	// The server provides document formatting on typing.
	DocumentOnTypeFormattingProvider *DocumentOnTypeFormattingOptions `json:"documentOnTypeFormattingProvider,omitempty"`
	// The server provides rename support. RenameOptions may only be
	// specified if the client states that it supports
	// `prepareSupport` in its initial `initialize` request.
	RenameProvider *BooleanOrRenameOptions `json:"renameProvider,omitempty"`
	// The server provides folding provider support.
	FoldingRangeProvider *BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions `json:"foldingRangeProvider,omitempty"`
	// The server provides selection range support.
	SelectionRangeProvider *BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions `json:"selectionRangeProvider,omitempty"`
	// The server provides execute command support.
	ExecuteCommandProvider *ExecuteCommandOptions `json:"executeCommandProvider,omitempty"`
	// The server provides call hierarchy support.
	//
	// @since 3.16.0
	CallHierarchyProvider *BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions `json:"callHierarchyProvider,omitempty"`
	// The server provides linked editing range support.
	//
	// @since 3.16.0
	LinkedEditingRangeProvider *BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions `json:"linkedEditingRangeProvider,omitempty"`
	// The server provides semantic tokens support.
	//
	// @since 3.16.0
	SemanticTokensProvider *SemanticTokensOptionsOrSemanticTokensRegistrationOptions `json:"semanticTokensProvider,omitempty"`
	// The server provides moniker support.
	//
	// @since 3.16.0
	MonikerProvider *BooleanOrMonikerOptionsOrMonikerRegistrationOptions `json:"monikerProvider,omitempty"`
	// The server provides type hierarchy support.
	//
	// @since 3.17.0
	TypeHierarchyProvider *BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions `json:"typeHierarchyProvider,omitempty"`
	// The server provides inline values.
	//
	// @since 3.17.0
	InlineValueProvider *BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions `json:"inlineValueProvider,omitempty"`
	// The server provides inlay hints.
	//
	// @since 3.17.0
	InlayHintProvider *BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions `json:"inlayHintProvider,omitempty"`
	// The server has support for pull model diagnostics.
	//
	// @since 3.17.0
	DiagnosticProvider *DiagnosticOptionsOrDiagnosticRegistrationOptions `json:"diagnosticProvider,omitempty"`
	// Inline completion options used during static registration.
	//
	// @since 3.18.0
	// @proposed
	InlineCompletionProvider *BooleanOrInlineCompletionOptions `json:"inlineCompletionProvider,omitempty"`
	// Workspace specific server capabilities.
	Workspace *ServerCapabilitiesWorkspace `json:"workspace,omitempty"`
	// Experimental server capabilities.
	Experimental LSPAny `json:"experimental,omitempty"`
}

type InitializeResultServerInfo struct {
	// The name of the server as defined by the server.
	Name string `json:"name"`
	// The server's version as defined by the server.
	Version string `json:"version,omitempty"`
}

// The result returned from an initialize request.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initializeResult
type InitializeResult struct {
	// The capabilities the language server provides.
	Capabilities *ServerCapabilities `json:"capabilities"`
	// Information about the server.
	//
	// @since 3.15.0
	ServerInfo *InitializeResultServerInfo `json:"serverInfo,omitempty"`
}

// The data type of the ResponseError if the
// initialize request fails.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initializeError
type InitializeError struct {
	// Indicates whether the client execute the following retry logic:
	// (1) show the message provided by the ResponseError to the user
	// (2) user selects retry or cancel
	// (3) if user selected retry the initialize method is sent again.
	Retry bool `json:"retry"`
}

// A literal to identify a text document in the client.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentIdentifier
type TextDocumentIdentifier struct {
	// The text document's uri.
	Uri string `json:"uri"`
}

// Position in a text document expressed as zero-based line and character
// offset. Prior to 3.17 the offsets were always based on a UTF-16 string
// representation. So a string of the form `a𐐀b` the character offset of the
// character `a` is 0, the character offset of `𐐀` is 1 and the character
// offset of b is 3 since `𐐀` is represented using two code units in UTF-16.
// Since 3.17 clients and servers can agree on a different string encoding
// representation (e.g. UTF-8). The client announces it's supported encoding
// via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
// The value is an array of position encodings the client supports, with
// decreasing preference (e.g. the encoding at index `0` is the most preferred
// one). To stay backwards compatible the only mandatory encoding is UTF-16
// represented via the string `utf-16`. The server can pick one of the
// encodings offered by the client and signals that encoding back to the
// client via the initialize result's property
// [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
// `utf-16` is missing from the client's capability `general.positionEncodings`
// servers can safely assume that the client supports UTF-16. If the server
// omits the position encoding in its initialize result the encoding defaults
// to the string value `utf-16`. Implementation considerations: since the
// conversion from one encoding into another requires the content of the
// file / line the conversion is best done where the file is read which is
// usually on the server side.
//
// Positions are line end character agnostic. So you can not specify a position
// that denotes `\r|\n` or `\n|` where `|` represents the character offset.
//
// @since 3.17.0 - support for negotiated position encoding.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#position
type Position struct {
	// Line position in a document (zero-based).
	//
	// If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
	// If a line number is negative, it defaults to 0.
	Line int `json:"line"`
	// Character offset on a line in a document (zero-based).
	//
	// The meaning of this offset is determined by the negotiated
	// `PositionEncodingKind`.
	//
	// If the character value is greater than the line length it defaults back to the
	// line length.
	Character int `json:"character"`
}

// A parameter literal used in requests to pass a text document and a position inside that
// document.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentPositionParams
type TextDocumentPositionParams struct {
	// The text document.
	TextDocument *TextDocumentIdentifier `json:"textDocument"`
	// The position inside the text document.
	Position *Position `json:"position"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#partialResultParams
type PartialResultParams struct {
	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken ProgressToken `json:"partialResultToken,omitempty"`
}

// Parameters for a {@link DefinitionRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#definitionParams
type DefinitionParams struct {
	*TextDocumentPositionParams
	*WorkDoneProgressParams
	*PartialResultParams
}

// A range in a text document expressed as (zero-based) start and end positions.
//
// If you want to specify a range that contains a line including the line ending
// character(s) then use an end position denoting the start of the next line.
// For example:
// ```ts
//
//	{
//	    start: { line: 5, character: 23 }
//	    end : { line 6, character : 0 }
//	}
//
// ```
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#range
type Range struct {
	// The range's start position.
	Start *Position `json:"start"`
	// The range's end position.
	End *Position `json:"end"`
}

// Represents a location inside a resource, such as a line
// inside a text file.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#location
type Location struct {
	Uri string `json:"uri"`

	Range *Range `json:"range"`
}

type LocationSlice []*Location

// LocationOrLocationSlice contains either of the following types:
//   - [*Location]
//   - [LocationSlice]
type LocationOrLocationSlice struct {
	Value LocationOrLocationSliceValue
}

// LocationOrLocationSliceValue is either of the following types:
//   - [*Location]
//   - [LocationSlice]
//
//gosumtype:decl LocationOrLocationSliceValue
type LocationOrLocationSliceValue interface {
	isLocationOrLocationSliceValue()
}

func (*Location) isLocationOrLocationSliceValue()     {}
func (LocationSlice) isLocationOrLocationSliceValue() {}

func (l *LocationOrLocationSlice) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var locationValue *Location
	if err := json.Unmarshal(data, &locationValue); err == nil {
		l.Value = locationValue
		return nil
	}
	var locationSliceValue LocationSlice
	if err := json.Unmarshal(data, &locationSliceValue); err == nil {
		l.Value = locationSliceValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*LocationOrLocationSlice](),
	}
}

func (l LocationOrLocationSlice) MarshalJSON() ([]byte, error) {
	return json.Marshal(l.Value)
}

// The definition of a symbol represented as one or many {@link Location locations}.
// For most programming languages there is only one location at which a symbol is
// defined.
//
// Servers should prefer returning `DefinitionLink` over `Definition` if supported
// by the client.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#definition
type Definition = *LocationOrLocationSlice

// Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
// including an origin range.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#locationLink
type LocationLink struct {
	// Span of the origin of this link.
	//
	// Used as the underlined span for mouse interaction. Defaults to the word range at
	// the definition position.
	OriginSelectionRange *Range `json:"originSelectionRange,omitempty"`
	// The target resource identifier of this link.
	TargetUri string `json:"targetUri"`
	// The full target range of this link. If the target for example is a symbol then target range is the
	// range enclosing this symbol not including leading/trailing whitespace but everything else
	// like comments. This information is typically used to highlight the range in the editor.
	TargetRange *Range `json:"targetRange"`
	// The range that should be selected and revealed when this link is being followed, e.g the name of a function.
	// Must be contained by the `targetRange`. See also `DocumentSymbol#range`
	TargetSelectionRange *Range `json:"targetSelectionRange"`
}

// Information about where a symbol is defined.
//
// Provides additional metadata over normal {@link Location location} definitions, including the range of
// the defining symbol
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#definitionLink
type DefinitionLink = *LocationLink

type DefinitionLinkSlice []DefinitionLink

// DefinitionOrDefinitionLinkSlice contains either of the following types:
//   - [Definition]
//   - [DefinitionLinkSlice]
type DefinitionOrDefinitionLinkSlice struct {
	Value DefinitionOrDefinitionLinkSliceValue
}

// DefinitionOrDefinitionLinkSliceValue is either of the following types:
//   - [Definition]
//   - [DefinitionLinkSlice]
//
//gosumtype:decl DefinitionOrDefinitionLinkSliceValue
type DefinitionOrDefinitionLinkSliceValue interface {
	isDefinitionOrDefinitionLinkSliceValue()
}

func (Definition) isDefinitionOrDefinitionLinkSliceValue()          {}
func (DefinitionLinkSlice) isDefinitionOrDefinitionLinkSliceValue() {}

func (d *DefinitionOrDefinitionLinkSlice) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var definitionValue Definition
	if err := json.Unmarshal(data, &definitionValue); err == nil {
		d.Value = definitionValue
		return nil
	}
	var definitionLinkSliceValue DefinitionLinkSlice
	if err := json.Unmarshal(data, &definitionLinkSliceValue); err == nil {
		d.Value = definitionLinkSliceValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*DefinitionOrDefinitionLinkSlice](),
	}
}

func (d DefinitionOrDefinitionLinkSlice) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Value)
}

// Value-object that contains additional information when
// requesting references.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#referenceContext
type ReferenceContext struct {
	// Include the declaration of the current symbol.
	IncludeDeclaration bool `json:"includeDeclaration"`
}

// Parameters for a {@link ReferencesRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#referenceParams
type ReferenceParams struct {
	*TextDocumentPositionParams
	*WorkDoneProgressParams
	*PartialResultParams

	Context *ReferenceContext `json:"context"`
}

// Parameters for a {@link DocumentSymbolRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentSymbolParams
type DocumentSymbolParams struct {
	*WorkDoneProgressParams
	*PartialResultParams
	// The text document.
	TextDocument *TextDocumentIdentifier `json:"textDocument"`
}

// A base for all symbol information.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#baseSymbolInformation
type BaseSymbolInformation struct {
	// The name of this symbol.
	Name string `json:"name"`
	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`
	// Tags for this symbol.
	//
	// @since 3.16.0
	Tags []SymbolTag `json:"tags,omitempty"`
	// The name of the symbol containing this symbol. This information is for
	// user interface purposes (e.g. to render a qualifier in the user interface
	// if necessary). It can't be used to re-infer a hierarchy for the document
	// symbols.
	ContainerName string `json:"containerName,omitempty"`
}

// Represents information about programming constructs like variables, classes,
// interfaces etc.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#symbolInformation
type SymbolInformation struct {
	*BaseSymbolInformation
	// Indicates if this symbol is deprecated.
	//
	// Deprecated: Use tags instead
	Deprecated bool `json:"deprecated,omitempty"`
	// The location of this symbol. The location's range is used by a tool
	// to reveal the location in the editor. If the symbol is selected in the
	// tool the range's start information is used to position the cursor. So
	// the range usually spans more than the actual symbol's name and does
	// normally include things like visibility modifiers.
	//
	// The range doesn't have to denote a node range in the sense of an abstract
	// syntax tree. It can therefore not be used to re-construct a hierarchy of
	// the symbols.
	Location *Location `json:"location"`
}

type SymbolInformationSlice []*SymbolInformation

// Represents programming constructs like variables, classes, interfaces etc.
// that appear in a document. Document symbols can be hierarchical and they
// have two ranges: one that encloses its definition and one that points to
// its most interesting range, e.g. the range of an identifier.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentSymbol
type DocumentSymbol struct {
	// The name of this symbol. Will be displayed in the user interface and therefore must not be
	// an empty string or a string only consisting of white spaces.
	Name string `json:"name"`
	// More detail for this symbol, e.g the signature of a function.
	Detail string `json:"detail,omitempty"`
	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`
	// Tags for this document symbol.
	//
	// @since 3.16.0
	Tags []SymbolTag `json:"tags,omitempty"`
	// Indicates if this symbol is deprecated.
	//
	// Deprecated: Use tags instead
	Deprecated bool `json:"deprecated,omitempty"`
	// The range enclosing this symbol not including leading/trailing whitespace but everything else
	// like comments. This information is typically used to determine if the clients cursor is
	// inside the symbol to reveal in the symbol in the UI.
	Range *Range `json:"range"`
	// The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
	// Must be contained by the `range`.
	SelectionRange *Range `json:"selectionRange"`
	// Children of this symbol, e.g. properties of a class.
	Children []*DocumentSymbol `json:"children,omitempty"`
}

type DocumentSymbolSlice []*DocumentSymbol

// SymbolInformationSliceOrDocumentSymbolSlice contains either of the following types:
//   - [SymbolInformationSlice]
//   - [DocumentSymbolSlice]
type SymbolInformationSliceOrDocumentSymbolSlice struct {
	Value SymbolInformationSliceOrDocumentSymbolSliceValue
}

// SymbolInformationSliceOrDocumentSymbolSliceValue is either of the following types:
//   - [SymbolInformationSlice]
//   - [DocumentSymbolSlice]
//
//gosumtype:decl SymbolInformationSliceOrDocumentSymbolSliceValue
type SymbolInformationSliceOrDocumentSymbolSliceValue interface {
	isSymbolInformationSliceOrDocumentSymbolSliceValue()
}

func (SymbolInformationSlice) isSymbolInformationSliceOrDocumentSymbolSliceValue() {}
func (DocumentSymbolSlice) isSymbolInformationSliceOrDocumentSymbolSliceValue()    {}

func (s *SymbolInformationSliceOrDocumentSymbolSlice) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var symbolInformationSliceValue SymbolInformationSlice
	if err := json.Unmarshal(data, &symbolInformationSliceValue); err == nil {
		s.Value = symbolInformationSliceValue
		return nil
	}
	var documentSymbolSliceValue DocumentSymbolSlice
	if err := json.Unmarshal(data, &documentSymbolSliceValue); err == nil {
		s.Value = documentSymbolSliceValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*SymbolInformationSliceOrDocumentSymbolSlice](),
	}
}

func (s SymbolInformationSliceOrDocumentSymbolSlice) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Value)
}

// Value-object describing what options formatting should use.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#formattingOptions
type FormattingOptions struct {
	// Size of a tab in spaces.
	TabSize int `json:"tabSize"`
	// Prefer spaces over tabs.
	InsertSpaces bool `json:"insertSpaces"`
	// Trim trailing whitespace on a line.
	//
	// @since 3.15.0
	TrimTrailingWhitespace bool `json:"trimTrailingWhitespace,omitempty"`
	// Insert a newline character at the end of the file if one does not exist.
	//
	// @since 3.15.0
	InsertFinalNewline bool `json:"insertFinalNewline,omitempty"`
	// Trim all newlines after the final newline at the end of the file.
	//
	// @since 3.15.0
	TrimFinalNewlines bool `json:"trimFinalNewlines,omitempty"`
}

// The parameters of a {@link DocumentFormattingRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentFormattingParams
type DocumentFormattingParams struct {
	*WorkDoneProgressParams
	// The document to format.
	TextDocument *TextDocumentIdentifier `json:"textDocument"`
	// The format options.
	Options *FormattingOptions `json:"options"`
}

// A text edit applicable to a text document.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textEdit
type TextEdit struct {
	// The range of the text document to be manipulated. To insert
	// text into a document create a range where start === end.
	Range *Range `json:"range"`
	// The string to be inserted. For delete operations use an
	// empty string.
	NewText string `json:"newText"`
}

// The parameters of a {@link RenameRequest}.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#renameParams
type RenameParams struct {
	*WorkDoneProgressParams
	// The document to rename.
	TextDocument *TextDocumentIdentifier `json:"textDocument"`
	// The position at which this request was sent.
	Position *Position `json:"position"`
	// The new name of the symbol. If the given name is not valid the
	// request must return a {@link ResponseError} with an
	// appropriate message set.
	NewName string `json:"newName"`
}

// A text document identifier to optionally denote a specific version of a text document.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#optionalVersionedTextDocumentIdentifier
type OptionalVersionedTextDocumentIdentifier struct {
	*TextDocumentIdentifier
	// The version number of this document. If a versioned text document identifier
	// is sent from the server to the client and the file is not open in the editor
	// (the server has not received an open notification before) the server can send
	// `null` to indicate that the version is unknown and the content on disk is the
	// truth (as specified with document content ownership).
	Version int `json:"version"`
}

// An identifier to refer to a change annotation stored with a workspace edit.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#changeAnnotationIdentifier
type ChangeAnnotationIdentifier = string

// A special text edit with an additional change annotation.
//
// @since 3.16.0.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#annotatedTextEdit
type AnnotatedTextEdit struct {
	*TextEdit
	// The actual identifier of the change annotation
	AnnotationId ChangeAnnotationIdentifier `json:"annotationId"`
}

// TextEditOrAnnotatedTextEdit contains either of the following types:
//   - [*TextEdit]
//   - [*AnnotatedTextEdit]
type TextEditOrAnnotatedTextEdit struct {
	Value TextEditOrAnnotatedTextEditValue
}

// TextEditOrAnnotatedTextEditValue is either of the following types:
//   - [*TextEdit]
//   - [*AnnotatedTextEdit]
//
//gosumtype:decl TextEditOrAnnotatedTextEditValue
type TextEditOrAnnotatedTextEditValue interface {
	isTextEditOrAnnotatedTextEditValue()
}

func (*TextEdit) isTextEditOrAnnotatedTextEditValue()          {}
func (*AnnotatedTextEdit) isTextEditOrAnnotatedTextEditValue() {}

func (t *TextEditOrAnnotatedTextEdit) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var textEditValue *TextEdit
	if err := json.Unmarshal(data, &textEditValue); err == nil {
		t.Value = textEditValue
		return nil
	}
	var annotatedTextEditValue *AnnotatedTextEdit
	if err := json.Unmarshal(data, &annotatedTextEditValue); err == nil {
		t.Value = annotatedTextEditValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*TextEditOrAnnotatedTextEdit](),
	}
}

func (t TextEditOrAnnotatedTextEdit) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.Value)
}

// Describes textual changes on a text document. A TextDocumentEdit describes all changes
// on a document version Si and after they are applied move the document to version Si+1.
// So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
// kind of ordering. However the edits must be non overlapping.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentEdit
type TextDocumentEdit struct {
	// The text document to change.
	TextDocument *OptionalVersionedTextDocumentIdentifier `json:"textDocument"`
	// The edits to be applied.
	//
	// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
	// client capability.
	Edits []*TextEditOrAnnotatedTextEdit `json:"edits"`
}

// A generic resource operation.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#resourceOperation
type ResourceOperation struct {
	// The resource operation kind.
	Kind string `json:"kind"`
	// An optional annotation identifier describing the operation.
	//
	// @since 3.16.0
	AnnotationId ChangeAnnotationIdentifier `json:"annotationId,omitempty"`
}

type CreateFileKind struct{}

func (CreateFileKind) String() string {
	return "create"
}

func (*CreateFileKind) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	if value != "create" {
		return fmt.Errorf("cannot unmarshal %v into CreateFileKind: value must be create", value)
	}
	return nil
}

func (CreateFileKind) MarshalJSON() ([]byte, error) {
	return json.Marshal("create")
}

// Options to create a file.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#createFileOptions
type CreateFileOptions struct {
	// Overwrite existing file. Overwrite wins over `ignoreIfExists`
	Overwrite bool `json:"overwrite,omitempty"`
	// Ignore if exists.
	IgnoreIfExists bool `json:"ignoreIfExists,omitempty"`
}

// Create file operation.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#createFile
type CreateFile struct {
	*ResourceOperation
	// A create
	Kind CreateFileKind `json:"kind"`
	// The resource to create.
	Uri string `json:"uri"`
	// Additional options
	Options *CreateFileOptions `json:"options,omitempty"`
}

type RenameFileKind struct{}

func (RenameFileKind) String() string {
	return "rename"
}

func (*RenameFileKind) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	if value != "rename" {
		return fmt.Errorf("cannot unmarshal %v into RenameFileKind: value must be rename", value)
	}
	return nil
}

func (RenameFileKind) MarshalJSON() ([]byte, error) {
	return json.Marshal("rename")
}

// Rename file options
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#renameFileOptions
type RenameFileOptions struct {
	// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
	Overwrite bool `json:"overwrite,omitempty"`
	// Ignores if target exists.
	IgnoreIfExists bool `json:"ignoreIfExists,omitempty"`
}

// Rename file operation
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#renameFile
type RenameFile struct {
	*ResourceOperation
	// A rename
	Kind RenameFileKind `json:"kind"`
	// The old (existing) location.
	OldUri string `json:"oldUri"`
	// The new location.
	NewUri string `json:"newUri"`
	// Rename options.
	Options *RenameFileOptions `json:"options,omitempty"`
}

type DeleteFileKind struct{}

func (DeleteFileKind) String() string {
	return "delete"
}

func (*DeleteFileKind) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	if value != "delete" {
		return fmt.Errorf("cannot unmarshal %v into DeleteFileKind: value must be delete", value)
	}
	return nil
}

func (DeleteFileKind) MarshalJSON() ([]byte, error) {
	return json.Marshal("delete")
}

// Delete file options
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#deleteFileOptions
type DeleteFileOptions struct {
	// Delete the content recursively if a folder is denoted.
	Recursive bool `json:"recursive,omitempty"`
	// Ignore the operation if the file doesn't exist.
	IgnoreIfNotExists bool `json:"ignoreIfNotExists,omitempty"`
}

// Delete file operation
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#deleteFile
type DeleteFile struct {
	*ResourceOperation
	// A delete
	Kind DeleteFileKind `json:"kind"`
	// The file to delete.
	Uri string `json:"uri"`
	// Delete options.
	Options *DeleteFileOptions `json:"options,omitempty"`
}

// TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile contains either of the following types:
//   - [*TextDocumentEdit]
//   - [*CreateFile]
//   - [*RenameFile]
//   - [*DeleteFile]
type TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile struct {
	Value TextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue
}

// TextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue is either of the following types:
//   - [*TextDocumentEdit]
//   - [*CreateFile]
//   - [*RenameFile]
//   - [*DeleteFile]
//
//gosumtype:decl TextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue
type TextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue interface {
	isTextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue()
}

func (*TextDocumentEdit) isTextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue() {}
func (*CreateFile) isTextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue()       {}
func (*RenameFile) isTextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue()       {}
func (*DeleteFile) isTextDocumentEditOrCreateFileOrRenameFileOrDeleteFileValue()       {}

func (t *TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var textDocumentEditValue *TextDocumentEdit
	if err := json.Unmarshal(data, &textDocumentEditValue); err == nil {
		t.Value = textDocumentEditValue
		return nil
	}
	var createFileValue *CreateFile
	if err := json.Unmarshal(data, &createFileValue); err == nil {
		t.Value = createFileValue
		return nil
	}
	var renameFileValue *RenameFile
	if err := json.Unmarshal(data, &renameFileValue); err == nil {
		t.Value = renameFileValue
		return nil
	}
	var deleteFileValue *DeleteFile
	if err := json.Unmarshal(data, &deleteFileValue); err == nil {
		t.Value = deleteFileValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile](),
	}
}

func (t TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.Value)
}

// Additional information that describes document changes.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#changeAnnotation
type ChangeAnnotation struct {
	// A human-readable string describing the actual change. The string
	// is rendered prominent in the user interface.
	Label string `json:"label"`
	// A flag which indicates that user confirmation is needed
	// before applying the change.
	NeedsConfirmation bool `json:"needsConfirmation,omitempty"`
	// A human-readable string which is rendered less prominent in
	// the user interface.
	Description string `json:"description,omitempty"`
}

// A workspace edit represents changes to many resources managed in the workspace. The edit
// should either provide `changes` or `documentChanges`. If documentChanges are present
// they are preferred over `changes` if the client can handle versioned document edits.
//
// Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
// operations are present clients need to execute the operations in the order in which they
// are provided. So a workspace edit for example can consist of the following two changes:
// (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
//
// An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
// cause failure of the operation. How the client recovers from the failure is described by
// the client capability: `workspace.workspaceEdit.failureHandling`
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspaceEdit
type WorkspaceEdit struct {
	// Holds changes to existing resources.
	Changes map[string][]*TextEdit `json:"changes,omitempty"`
	// Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
	// are either an array of `TextDocumentEdit`s to express changes to n different text documents
	// where each text document edit addresses a specific version of a text document. Or it can contain
	// above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
	//
	// Whether a client supports versioned document edits is expressed via
	// `workspace.workspaceEdit.documentChanges` client capability.
	//
	// If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
	// only plain `TextEdit`s using the `changes` property are supported.
	DocumentChanges []*TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile `json:"documentChanges,omitempty"`
	// A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
	// delete file / folder operations.
	//
	// Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
	//
	// @since 3.16.0
	ChangeAnnotations map[ChangeAnnotationIdentifier]*ChangeAnnotation `json:"changeAnnotations,omitempty"`
}

// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initializedParams
type InitializedParams struct {
}

// The message type
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#messageType
type MessageType uint32

const (
	// An error message.
	MessageTypeError MessageType = 1
	// A warning message.
	MessageTypeWarning MessageType = 2
	// An information message.
	MessageTypeInfo MessageType = 3
	// A log message.
	MessageTypeLog MessageType = 4
	// A debug message.
	//
	// @since 3.18.0
	MessageTypeDebug MessageType = 5
)

var validMessageTypeValues = map[uint32]bool{
	1: true,
	2: true,
	3: true,
	4: true,
	5: true,
}

func (m *MessageType) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validMessageTypeValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into MessageType: custom values are not supported", uint32Value)
	}
	*m = MessageType(uint32Value)

	return nil
}

func (m MessageType) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(m)
	if !validMessageTypeValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into MessageType: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

// The log message parameters.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#logMessageParams
type LogMessageParams struct {
	// The message type. See {@link MessageType}
	Type MessageType `json:"type"`
	// The actual message.
	Message string `json:"message"`
}

// An item to transfer a text document from the client to the
// server.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentItem
type TextDocumentItem struct {
	// The text document's uri.
	Uri string `json:"uri"`
	// The text document's language identifier.
	LanguageId string `json:"languageId"`
	// The version number of this document (it will increase after each
	// change, including undo/redo).
	Version int `json:"version"`
	// The content of the opened text document.
	Text string `json:"text"`
}

// The parameters sent in an open text document notification
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#didOpenTextDocumentParams
type DidOpenTextDocumentParams struct {
	// The document that was opened.
	TextDocument *TextDocumentItem `json:"textDocument"`
}

// A text document identifier to denote a specific version of a text document.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#versionedTextDocumentIdentifier
type VersionedTextDocumentIdentifier struct {
	*TextDocumentIdentifier
	// The version number of this document.
	Version int `json:"version"`
}

type IncrementalTextDocumentContentChangeEvent struct {
	// The range of the document that changed.
	Range *Range `json:"range"`
	// The optional length of the range that got replaced.
	//
	// @deprecated use range instead.
	RangeLength int `json:"rangeLength,omitempty"`
	// The new text for the provided range.
	Text string `json:"text"`
}

type FullTextDocumentContentChangeEvent struct {
	// The new text of the whole document.
	Text string `json:"text"`
}

// IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent contains either of the following types:
//   - [*IncrementalTextDocumentContentChangeEvent]
//   - [*FullTextDocumentContentChangeEvent]
type IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent struct {
	Value IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue
}

// IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue is either of the following types:
//   - [*IncrementalTextDocumentContentChangeEvent]
//   - [*FullTextDocumentContentChangeEvent]
//
//gosumtype:decl IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue
type IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue interface {
	isIncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue()
}

func (*IncrementalTextDocumentContentChangeEvent) isIncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue() {
}
func (*FullTextDocumentContentChangeEvent) isIncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEventValue() {
}

func (i *IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var unmarshalledData map[string]any
	err := json.Unmarshal(data, &unmarshalledData)
	if err != nil {
		return err
	}
	fields := slices.Collect(maps.Keys(unmarshalledData))
	var incrementalTextDocumentContentChangeEventValue *IncrementalTextDocumentContentChangeEvent
	if slices.Contains(fields, "range") {
		if err := json.Unmarshal(data, &incrementalTextDocumentContentChangeEventValue); err == nil {
			i.Value = incrementalTextDocumentContentChangeEventValue
			return nil
		}
	}
	var fullTextDocumentContentChangeEventValue *FullTextDocumentContentChangeEvent
	if err := json.Unmarshal(data, &fullTextDocumentContentChangeEventValue); err == nil {
		i.Value = fullTextDocumentContentChangeEventValue
		return nil
	}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent](),
	}
}

func (i IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.Value)
}

// An event describing a change to a text document. If only a text is provided
// it is considered to be the full content of the document.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocumentContentChangeEvent
type TextDocumentContentChangeEvent = *IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent

// The change text document notification's parameters.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#didChangeTextDocumentParams
type DidChangeTextDocumentParams struct {
	// The document that did change. The version number points
	// to the version after all provided content changes have
	// been applied.
	TextDocument *VersionedTextDocumentIdentifier `json:"textDocument"`
	// The actual content changes. The content changes describe single state changes
	// to the document. So if there are two content changes c1 (at array index 0) and
	// c2 (at array index 1) for a document in state S then c1 moves the document from
	// S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
	// on the state S'.
	//
	// To mirror the content of a document using change events use the following approach:
	// - start with the same initial content
	// - apply the 'textDocument/didChange' notifications in the order you receive them.
	// - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
	//   you receive them.
	ContentChanges []TextDocumentContentChangeEvent `json:"contentChanges"`
}

// The parameters sent in a close text document notification
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#didCloseTextDocumentParams
type DidCloseTextDocumentParams struct {
	// The document that was closed.
	TextDocument *TextDocumentIdentifier `json:"textDocument"`
}

// The diagnostic's severity.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticSeverity
type DiagnosticSeverity uint32

const (
	// Reports an error.
	DiagnosticSeverityError DiagnosticSeverity = 1
	// Reports a warning.
	DiagnosticSeverityWarning DiagnosticSeverity = 2
	// Reports an information.
	DiagnosticSeverityInformation DiagnosticSeverity = 3
	// Reports a hint.
	DiagnosticSeverityHint DiagnosticSeverity = 4
)

var validDiagnosticSeverityValues = map[uint32]bool{
	1: true,
	2: true,
	3: true,
	4: true,
}

func (d *DiagnosticSeverity) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	var uint32Value uint32
	if err := json.Unmarshal(data, &uint32Value); err != nil {
		return err
	}
	if !validDiagnosticSeverityValues[uint32Value] {
		return fmt.Errorf("cannot unmarshal %v into DiagnosticSeverity: custom values are not supported", uint32Value)
	}
	*d = DiagnosticSeverity(uint32Value)

	return nil
}

func (d DiagnosticSeverity) MarshalJSON() ([]byte, error) {
	var uint32Value = uint32(d)
	if !validDiagnosticSeverityValues[uint32Value] {
		return nil, fmt.Errorf("cannot marshal %v into DiagnosticSeverity: custom values are not supported", uint32Value)
	}
	return json.Marshal(uint32Value)

}

// Structure to capture a description for an error code.
//
// @since 3.16.0
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeDescription
type CodeDescription struct {
	// An URI to open with more information about the diagnostic error.
	Href string `json:"href"`
}

// Represents a related message and source code location for a diagnostic. This should be
// used to point to code locations that cause or related to a diagnostics, e.g when duplicating
// a symbol in a scope.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticRelatedInformation
type DiagnosticRelatedInformation struct {
	// The location of this related diagnostic information.
	Location *Location `json:"location"`
	// The message of this related diagnostic information.
	Message string `json:"message"`
}

// Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
// are only valid in the scope of a resource.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnostic
type Diagnostic struct {
	// The range at which the message applies
	Range *Range `json:"range"`
	// The diagnostic's severity. Can be omitted. If omitted it is up to the
	// client to interpret diagnostics as error, warning, info or hint.
	Severity DiagnosticSeverity `json:"severity,omitempty"`
	// The diagnostic's code, which usually appear in the user interface.
	Code *IntegerOrString `json:"code,omitempty"`
	// An optional property to describe the error code.
	// Requires the code field (above) to be present/not null.
	//
	// @since 3.16.0
	CodeDescription *CodeDescription `json:"codeDescription,omitempty"`
	// A human-readable string describing the source of this
	// diagnostic, e.g. 'typescript' or 'super lint'. It usually
	// appears in the user interface.
	Source string `json:"source,omitempty"`
	// The diagnostic's message. It usually appears in the user interface
	Message string `json:"message"`
	// Additional metadata about the diagnostic.
	//
	// @since 3.15.0
	Tags []DiagnosticTag `json:"tags,omitempty"`
	// An array of related diagnostic information, e.g. when symbol-names within
	// a scope collide all definitions can be marked via this property.
	RelatedInformation []*DiagnosticRelatedInformation `json:"relatedInformation,omitempty"`
	// A data entry field that is preserved between a `textDocument/publishDiagnostics`
	// notification and `textDocument/codeAction` request.
	//
	// @since 3.16.0
	Data LSPAny `json:"data,omitempty"`
}

// The publish diagnostic notification's parameters.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#publishDiagnosticsParams
type PublishDiagnosticsParams struct {
	// The URI for which diagnostic information is reported.
	Uri string `json:"uri"`
	// Optional the version number of the document the diagnostics are published for.
	//
	// @since 3.15.0
	Version int `json:"version,omitempty"`
	// An array of diagnostic information items.
	Diagnostics []*Diagnostic `json:"diagnostics"`
}

// Predefined error codes.
//
// https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#errorCodes
type ErrorCodes int32

const (
	ErrorCodesParseError     ErrorCodes = -32700
	ErrorCodesInvalidRequest ErrorCodes = -32600
	ErrorCodesMethodNotFound ErrorCodes = -32601
	ErrorCodesInvalidParams  ErrorCodes = -32602
	ErrorCodesInternalError  ErrorCodes = -32603
	// Error code indicating that a server received a notification or
	// request before the server has received the `initialize` request.
	ErrorCodesServerNotInitialized ErrorCodes = -32002
	ErrorCodesUnknownErrorCode     ErrorCodes = -32001
)
