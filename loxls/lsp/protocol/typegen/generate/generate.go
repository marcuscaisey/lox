// Package generate provides a function to generate Go source code for LSP types.
package generate

import (
	"cmp"
	"fmt"
	"maps"
	"os"
	"slices"
	"strings"
	"text/template"

	"github.com/marcuscaisey/lox/loxls/lsp/protocol/typegen/metamodel"
)

var sumTypeVariantNameOverrides = map[string]string{
	"TextDocumentContentChangeEventOr1":      "IncrementalTextDocumentContentChangeEvent",
	"TextDocumentContentChangeEventOr2":      "FullTextDocumentContentChangeEvent",
	"CompletionListItemDefaultsEditRangeOr2": "InsertReplaceRange",
}

var sumTypeVariantDiscriminators = map[string]map[string]string{
	"IncrementalTextDocumentContentChangeEventOrFullTextDocumentContentChangeEvent": {
		"*IncrementalTextDocumentContentChangeEvent": "range",
	},
}

// Source returns an unformatted Go source file containing declarations of the given types.
// Types are resolved using the given meta model.
// The file will belong to the given package.
func Source(types []*metamodel.Type, metaModel *metamodel.MetaModel, pkg string) string {
	generator := newGenerator(types, metaModel, pkg)
	return generator.Source()
}

type generator struct {
	types     []*metamodel.Type
	metaModel *metamodel.MetaModel
	pkg       string

	typeDecls    []string
	importedPkgs map[string]struct{}
	gennedTypes  map[string]bool
}

func newGenerator(types []*metamodel.Type, metaModel *metamodel.MetaModel, pkg string) *generator {
	g := &generator{
		types:        types,
		metaModel:    metaModel,
		pkg:          pkg,
		importedPkgs: map[string]struct{}{},
		gennedTypes:  map[string]bool{},
	}
	return g
}

func (g *generator) Source() string {
	for _, typ := range g.types {
		if isNullBaseType(typ) {
			continue
		}
		namespace := ""
		g.genTypeDecl(namespace, typ)
	}

	const text = `
// Code generated by "typegen{{if .args}} {{.args}}{{end}}"; DO NOT EDIT.
package {{.package}}

{{if .importedPackages}}
import (
{{range .importedPackages}}
	"{{.}}"
{{- end}}
)
{{end}}

{{range .typeDeclarations}}
{{.}}
{{end}}
`
	data := map[string]any{
		"args":             strings.Join(os.Args[1:], " "),
		"package":          g.pkg,
		"importedPackages": slices.Collect(maps.Keys(g.importedPkgs)),
		"typeDeclarations": g.typeDecls,
	}
	return mustExecuteTemplate(text, data)
}

func (g *generator) genTypeDecl(namespace string, typ *metamodel.Type) string {
	switch typ := typ.Value.(type) {
	case metamodel.ReferenceType:
		return g.genRefTypeDecl(typ.Name)
	case metamodel.OrType:
		return g.genSumTypeDecl(namespace, typ.Items)
	case metamodel.BaseType:
		return g.baseType(typ.Name)
	case metamodel.StructureLiteralType:
		return g.genStructDeclForLiteral(namespace, typ.Value)
	case metamodel.StringLiteralType:
		return g.genStringLiteralDecl(namespace, typ.Value)
	case metamodel.ArrayType:
		return g.sliceType(namespace, typ.Element)
	case metamodel.MapType:
		return g.mapType(namespace, typ.Key, typ.Value)
	case metamodel.AndType, metamodel.BooleanLiteralType, metamodel.IntegerLiteralType, metamodel.TupleType:
		panic(fmt.Sprintf("unhandled type: %T", typ))
	}
	panic("unreachable")
}

func (g *generator) genTypeDeclForSumType(namespace string, typ *metamodel.Type) string {
	switch typValue := typ.Value.(type) {
	case metamodel.BaseType:
		return g.genBaseTypeDecl(typValue.Name)
	case metamodel.ArrayType:
		return g.genSliceDecl(namespace, typValue.Element)
	case metamodel.MapType:
		return g.genMapDecl(namespace, typValue.Key, typValue.Value)
	default:
		return g.genTypeDecl(namespace, typ)
	}
}

func (g *generator) genRefTypeDecl(name string) string {
	if structure, ok := g.metaModel.Structure(name); ok {
		return g.genStructDecl(structure)
	} else if alias, ok := g.metaModel.TypeAlias(name); ok {
		return g.genTypeAliasDecl(alias)
	} else if enum, ok := g.metaModel.Enumeration(name); ok {
		return g.genEnumDecl(enum)
	} else {
		panic(fmt.Sprintf("invalid reference type: %s", name))
	}
}

func (g *generator) genStructDecl(structure *metamodel.Structure) string {
	name := sanitiseName(structure.Name)

	if g.gennedTypes[name] {
		return "*" + name
	}
	g.gennedTypes[name] = true

	comment := g.commentForType(name, structure.Documentation, structure.Deprecated)
	var fields []string
	for _, typ := range slices.Concat(structure.Extends, structure.Mixins) {
		typ, ok := typ.Value.(metamodel.ReferenceType)
		if !ok {
			panic("non-reference parent type or mixin not supported")
		}
		fields = append(fields, g.genRefTypeDecl(typ.Name))
	}
	fieldData := make([]*structFieldData, len(structure.Properties))
	for i, prop := range structure.Properties {
		fieldData[i] = g.structFieldData(name, prop)
		fields = append(fields, structField(fieldData[i]))
	}

	const text = `
{{.comment}}
type {{.name}} struct {
	{{- range .fields}}
	{{.}}
	{{- end}}
}

{{with $receiver := slice $.name 0 1 | lowerFirstLetter}}
{{range $.fieldData}}
func ({{$receiver}} *{{$.name}}) Get{{.Name}}() {{.Type}} {
	if {{$receiver}} == nil {
		return *new({{.Type}})
	}
	return {{$receiver}}.{{.Name}}
}
{{end}}
{{end}}
`
	data := map[string]any{"comment": comment, "name": name, "fields": fields, "fieldData": fieldData}
	decl := mustExecuteTemplate(text, data)
	g.typeDecls = append(g.typeDecls, decl)

	return "*" + name
}

type structFieldData struct {
	Comment  string
	Optional bool
	Name     string
	Type     string
	JSONName string
}

func (g *generator) structFieldData(structName string, prop *metamodel.Property) *structFieldData {
	name := upperFirstLetter(sanitiseName(prop.Name))
	return &structFieldData{
		Comment:  g.comment(prop.Documentation, prop.Deprecated),
		Optional: prop.Optional,
		Name:     name,
		Type:     g.genTypeDecl(structName+name, prop.Type),
		JSONName: prop.Name,
	}
}

func structField(data *structFieldData) string {
	const text = `
{{- if .data.Comment}}
{{- .data.Comment}}
{{end}}
{{- if .data.Optional}}
{{- .data.Name}} {{.data.Type}} {{jsonTag .data.JSONName "omitempty"}}
{{- else}}
{{- .data.Name}} {{.data.Type}} {{jsonTag .data.JSONName}}
{{- end -}}
`
	return mustExecuteTemplate(text, map[string]any{"data": data})
}

func (g *generator) genTypeAliasDecl(typeAlias *metamodel.TypeAlias) string {
	name := sanitiseName(typeAlias.Name)

	if g.gennedTypes[name] {
		return name
	}
	g.gennedTypes[name] = true

	const text = `
{{.comment}}
type {{.name}} = {{.type}}
`
	data := map[string]any{
		"name":    name,
		"comment": g.commentForType(name, typeAlias.Documentation, typeAlias.Deprecated),
		"type":    g.genTypeDecl(name, typeAlias.Type),
	}
	decl := mustExecuteTemplate(text, data)
	g.typeDecls = append(g.typeDecls, decl)

	return name
}

var enumTypeTypes = map[metamodel.EnumerationTypeName]string{
	metamodel.EnumerationTypeNameString:   "string",
	metamodel.EnumerationTypeNameInteger:  "int32",
	metamodel.EnumerationTypeNameUinteger: "uint32",
}

func (g *generator) genEnumDecl(enum *metamodel.Enumeration) string {
	name := sanitiseName(enum.Name)

	if g.gennedTypes[name] {
		return name
	}
	g.gennedTypes[name] = true

	comment := g.commentForType(name, enum.Documentation, enum.Deprecated)

	typ, ok := enumTypeTypes[enum.Type.Name]
	if !ok {
		panic(fmt.Sprintf("unhandled enumeration type: %s", enum.Type.Name))
	}

	type enumMember struct {
		Comment, Name, Value string
	}
	members := make([]enumMember, len(enum.Values))
	for i, entry := range enum.Values {
		var value string
		switch entry := entry.Value.Value.(type) {
		case metamodel.Int:
			value = fmt.Sprint(entry)
		case metamodel.String:
			value = fmt.Sprintf("%q", entry)
		}
		members[i] = enumMember{
			Comment: g.comment(entry.Documentation, entry.Deprecated),
			Name:    fmt.Sprintf("%s%s", name, entry.Name),
			Value:   value,
		}
	}

	const text = `
{{.comment}}
type {{.name}} {{.type}}

const (
	{{- range .members}}
	{{- if ne .Comment ""}}
	{{.Comment}}
	{{- end}}
	{{.Name}} {{$.name}} = {{.Value}}
	{{- end}}
)

{{if not .supportsCustomValues}}
{{with $validValuesVar := printf "valid%sValues" .name}}
var {{$validValuesVar}} = map[{{$.type}}]bool{
	{{- range $.members}}
	{{.Value}}: true,
	{{- end}}
}

{{with $receiver := slice $.name 0 1 | lowerFirstLetter}}
func ({{$receiver}} *{{$.name}}) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	{{- with $valueVar := lowerFirstLetter $.type | printf "%sValue"}}
	var {{$valueVar}} {{$.type}}
	if err := json.Unmarshal(data, &{{$valueVar}}); err != nil {
		return err
	}
	if !{{$validValuesVar}}[{{$valueVar}}] {
		return fmt.Errorf("cannot unmarshal %v into {{$.name}}: custom values are not supported", {{$valueVar}})
	}
	*{{$receiver}} = {{$.name}}({{$valueVar}})
	{{end}}
	return nil
}

func ({{$receiver}} {{$.name}}) MarshalJSON() ([]byte, error) {
	{{- with $valueVar := lowerFirstLetter $.type | printf "%sValue"}}
	var {{$valueVar}} = {{$.type}}({{$receiver}})
	if !{{$validValuesVar}}[{{$valueVar}}] {
		return nil, fmt.Errorf("cannot marshal %v into {{$.name}}: custom values are not supported", {{$valueVar}})
	}
	return json.Marshal({{$valueVar}})
	{{end}}
}
{{end}}
{{end}}
{{end}}
`
	g.importPkgs("fmt")
	data := map[string]any{"comment": comment, "name": name, "type": typ, "members": members, "supportsCustomValues": enum.SupportsCustomValues}
	decl := mustExecuteTemplate(text, data)
	g.typeDecls = append(g.typeDecls, decl)

	return name
}

func (g *generator) genSumTypeDecl(namespace string, variants []*metamodel.Type) (name string) {
	nonNullVariants := slices.DeleteFunc(slices.Clone(variants), isNullBaseType)
	if len(nonNullVariants) == 1 {
		return g.genTypeDecl(namespace, nonNullVariants[0])
	}

	variantTypes := make([]string, len(nonNullVariants))
	for i, item := range nonNullVariants {
		name := fmt.Sprintf("%sOr%d", namespace, i+1)
		if override, ok := sumTypeVariantNameOverrides[name]; ok {
			name = override
		}
		variantTypes[i] = g.genTypeDeclForSumType(name, item)
	}

	name = strings.ReplaceAll(strings.Join(variantTypes, "Or"), "*", "")

	sortedVariantTypes := slices.Clone(variantTypes)
	discriminators := sumTypeVariantDiscriminators[name]
	// Sort the variants so that the ones with discriminators come first.
	slices.SortStableFunc(sortedVariantTypes, func(left, right string) int {
		var x int
		var y int
		if _, ok := discriminators[left]; !ok {
			x = 1
		}
		if _, ok := discriminators[right]; !ok {
			y = 1
		}
		return cmp.Compare(x, y)
	})

	if g.gennedTypes[name] {
		return "*" + name
	}
	g.gennedTypes[name] = true

	const text = `
{{with $interface := .name | printf "%sValue" -}}
// {{$.name}} contains either of the following types:
{{- range $.variants}}
//   - [{{.}}]
{{- end}}
type {{$.name}} struct {
	Value {{$interface}}
}

{{with $interfaceMethod := $interface | printf "is%s" -}}
// {{$interface}} is either of the following types:{{- range $.variants}}
//   - [{{.}}]
{{- end}}
//
//gosumtype:decl ` + /* Directive split up so that it doesn't get picked up as an actual declaration. */ `{{$interface}}
type {{$interface}} interface {
	{{$interfaceMethod}}()
}
{{range $.variants}}
func ({{.}}) {{$interfaceMethod}}() {}
{{- end}}
{{- end}}
{{- end}}

{{with $receiver := slice .name 0 1 | lowerFirstLetter}}
func ({{$receiver}} *{{$.name}}) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, []byte("null")) {
		return nil
	}
	{{- if gt (len $.discriminators) 0}}
	var unmarshalledData map[string]any
	err := json.Unmarshal(data, &unmarshalledData)
	if err != nil {
		return err
	}
	fields := slices.Collect(maps.Keys(unmarshalledData))
	{{- end}}
	{{- range $i, $variant := $.sortedVariants}}
	{{- with $var := trimStarPrefix $variant | lowerFirstLetter | printf "%sValue"}}
	var {{$var}} {{$variant}}
	{{- with $discriminator := index $.discriminators $variant}}
	if slices.Contains(fields, "{{$discriminator}}") {
		if err := json.Unmarshal(data, &{{$var}}); err == nil {
			{{$receiver}}.Value = {{$var}}
			return nil
		}
	}
	{{- else}}
	if err := json.Unmarshal(data, &{{$var}}); err == nil {
		{{$receiver}}.Value = {{$var}}
		return nil
	}
	{{- end}}
	{{- end}}
	{{- end}}
	return &json.UnmarshalTypeError{
		Value: string(data),
		Type:  reflect.TypeFor[*{{$.name}}](),
	}
}

func ({{$receiver}} *{{$.name}}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{$receiver}}.Value)
}
{{end}}
`
	g.importPkgs("bytes", "encoding/json", "reflect")
	if len(discriminators) > 0 {
		g.importPkgs("maps", "slices")
	}
	data := map[string]any{
		"name":           name,
		"variants":       variantTypes,
		"sortedVariants": sortedVariantTypes,
		"discriminators": discriminators,
	}
	decl := mustExecuteTemplate(text, data)
	g.typeDecls = append(g.typeDecls, decl)

	return "*" + name
}

var baseTypeTypes = map[metamodel.BaseTypes]string{
	metamodel.BaseTypesURI:         "string",
	metamodel.BaseTypesDocumentURI: "string",
	metamodel.BaseTypesInteger:     "int",
	metamodel.BaseTypesUinteger:    "int",
	metamodel.BaseTypesDecimal:     "float64",
	metamodel.BaseTypesRegExp:      "*regexp.Regexp",
	metamodel.BaseTypesString:      "string",
	metamodel.BaseTypesBoolean:     "bool",
	metamodel.BaseTypesNull:        "",
}

func (g *generator) baseType(baseType metamodel.BaseTypes) string {
	typ := baseTypeTypes[baseType]
	if typ == "" {
		panic(fmt.Sprintf("unhandled base type: %s", baseType))
	}
	return typ
}

func (g *generator) genBaseTypeDecl(baseType metamodel.BaseTypes) string {
	typ := baseTypeTypes[baseType]
	if typ == "" {
		panic(fmt.Sprintf("unhandled base type: %s", baseType))
	}
	name := upperFirstLetter(string(baseType))
	if g.gennedTypes[name] {
		return name
	}
	g.gennedTypes[name] = true
	decl := fmt.Sprintf("type %s %s", name, typ)
	g.typeDecls = append(g.typeDecls, decl)
	return name
}

func (g *generator) genStructDeclForLiteral(name string, structLiteral metamodel.StructureLiteral) string {
	if g.gennedTypes[name] {
		return "*" + name
	}
	g.gennedTypes[name] = true

	comment := g.comment(structLiteral.Documentation, structLiteral.Deprecated)
	fields := make([]string, len(structLiteral.Properties))
	fieldData := make([]*structFieldData, len(structLiteral.Properties))
	for i, prop := range structLiteral.Properties {
		fieldData[i] = g.structFieldData(name, prop)
		fields[i] = structField(fieldData[i])
	}

	const text = `
{{.comment}}
type {{.name}} struct {
	{{- range .fields}}
	{{.}}
	{{- end}}
}

{{with $receiver := slice $.name 0 1 | lowerFirstLetter}}
{{range $.fieldData}}
func ({{$receiver}} *{{$.name}}) Get{{.Name}}() {{.Type}} {
	if {{$receiver}} == nil {
		return *new({{.Type}})
	}
	return {{$receiver}}.{{.Name}}
}
{{end}}
{{end}}
`
	data := map[string]any{"comment": comment, "name": name, "fields": fields, "fieldData": fieldData}
	decl := mustExecuteTemplate(text, data)
	g.typeDecls = append(g.typeDecls, decl)

	return "*" + name
}

func (g *generator) genStringLiteralDecl(name string, value string) string {
	if g.gennedTypes[name] {
		return name
	}
	g.gennedTypes[name] = true

	const text = `
type {{.name}} struct{}

func ({{.name}}) String() string {
	return "{{.value}}"
}

func (*{{.name}}) UnmarshalJSON(data []byte) error {
	var value string
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	if value != "{{.value}}" {
		return fmt.Errorf("cannot unmarshal %v into {{.name}}: value must be {{.value}}", value)
	}
	return nil
}

func ({{.name}}) MarshalJSON() ([]byte, error) {
	return json.Marshal("{{.value}}")
}
`
	data := map[string]any{"name": name, "value": value}
	decl := mustExecuteTemplate(text, data)
	g.typeDecls = append(g.typeDecls, decl)

	return name
}

func (g *generator) sliceType(namespace string, elementType *metamodel.Type) string {
	if namespace == "LSPArray" {
		// We need to generate a type for this because its a variant of the LSPAny sum type.
		return g.genSliceDecl(namespace, elementType)
	}
	goElementType := g.genTypeDecl(namespace, elementType)
	return fmt.Sprintf("[]%s", goElementType)
}

func (g *generator) genSliceDecl(namespace string, elementType *metamodel.Type) string {
	goElementType := g.genTypeDecl(namespace, elementType)
	name := fmt.Sprintf("%sSlice", trimStarPrefix(goElementType))
	if g.gennedTypes[name] {
		return name
	}
	g.gennedTypes[name] = true
	g.typeDecls = append(g.typeDecls, fmt.Sprintf("type %s []%s", name, goElementType))
	return name
}

func (g *generator) mapType(namespace string, keyType metamodel.MapKeyType, valueType *metamodel.Type) string {
	if namespace == "LSPObject" {
		// We need to generate a type for this because its a variant of the LSPAny sum type.
		return g.genMapDecl(namespace, keyType, valueType)
	}
	var goKeyType string
	switch key := keyType.Value.(type) {
	case metamodel.BaseMapKeyType:
		goKeyType = g.baseType(key.Name.BaseTypes())
	case metamodel.ReferenceType:
		goKeyType = g.genRefTypeDecl(key.Name)
	}
	goValueType := g.genTypeDecl(namespace, valueType)
	return fmt.Sprintf("map[%s]%s", goKeyType, goValueType)
}

func (g *generator) genMapDecl(namespace string, keyType metamodel.MapKeyType, valueType *metamodel.Type) string {
	var goKeyType string
	switch key := keyType.Value.(type) {
	case metamodel.BaseMapKeyType:
		goKeyType = g.baseType(key.Name.BaseTypes())
	case metamodel.ReferenceType:
		goKeyType = g.genRefTypeDecl(key.Name)
	}
	goValueType := g.genTypeDecl(namespace, valueType)
	name := fmt.Sprintf("%s%sMap", goKeyType, goValueType)
	if g.gennedTypes[name] {
		return name
	}
	g.gennedTypes[name] = true
	decl := fmt.Sprintf("type %s map[%s]%s", name, goKeyType, goValueType)
	g.typeDecls = append(g.typeDecls, decl)
	return name
}

func (g *generator) importPkgs(pkgs ...string) {
	for _, pkg := range pkgs {
		g.importedPkgs[pkg] = struct{}{}
	}
}

func (g *generator) comment(documentation, deprecationMsg string) string {
	comment := documentation
	if deprecationMsg != "" {
		if strings.Contains(comment, "@deprecated") {
			comment = strings.ReplaceAll(comment, "@deprecated", "Deprecated:")
		} else {
			if comment != "" {
				comment += "\n\n"
			}
			comment += "Deprecated: " + deprecationMsg
		}
	}
	if comment != "" {
		return "// " + strings.ReplaceAll(comment, "\n", "\n// ")
	} else {
		return ""
	}
}

func (g *generator) commentForType(name, documentation, deprecationMsg string) string {
	comment := g.comment(documentation, deprecationMsg)
	versionParts := strings.Split(g.metaModel.MetaData.Version, ".")
	major, minor := versionParts[0], versionParts[1]
	if comment != "" {
		comment += "\n//\n"
	}
	comment += fmt.Sprintf("// https://microsoft.github.io/language-server-protocol/specifications/lsp/%s.%s/specification/#%s", major, minor, lowerFirstLetter(name))
	return comment
}

func mustExecuteTemplate(text string, data map[string]any) string {
	funcMap := template.FuncMap{
		"jsonTag":          jsonTag,
		"lowerFirstLetter": lowerFirstLetter,
		"trimStarPrefix":   trimStarPrefix,
	}
	tmpl := template.Must(template.New("template").Funcs(funcMap).Parse(text))
	var b strings.Builder
	if err := tmpl.Execute(&b, data); err != nil {
		panic(err)
	}
	return b.String()
}

func lowerFirstLetter(s string) string {
	return strings.ToLower(s[0:1]) + s[1:]
}

func upperFirstLetter(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}

func jsonTag(name string, opts ...string) string {
	return fmt.Sprintf("`json:%q`", strings.Join(append([]string{name}, opts...), ","))
}

func isNullBaseType(typ *metamodel.Type) bool {
	baseType, ok := typ.Value.(metamodel.BaseType)
	return ok && baseType.Name == metamodel.BaseTypesNull
}

func trimStarPrefix(s string) string {
	return strings.TrimPrefix(s, "*")
}

func sanitiseName(name string) string {
	if name[0] == '_' {
		return "X" + name[1:]
	}
	return name
}
